### 漏洞简介



CVE-2020-14145 是一个存在于 OpenSSH 客户端（版本 5.7至8.4）中的信息泄露漏洞。该漏洞源于客户端在与服务端进行算法协商过程中的一种“可观察到的差异”（Observable Discrepancy）。攻击者可以利用这种差异，在中间人攻击（Man-in-the-Middle, MitM）场景下，判断出客户端是否是首次连接该服务器。

简单来说，当一个 OpenSSH 客户端首次连接到一个 SSH 服务器时，它不知道该服务器的公钥指纹，因此会提示用户确认。如果客户端之前已经连接过该服务器，则会将服务器的公钥信息缓存在本地的 `known_hosts` 文件中。下次连接时，客户端会使用这个已缓存的密钥信息。

CVE-2020-14145 的核心在于，客户端在连接时，会向服务器发送一份其支持的服务器主机密钥算法列表。这个列表的顺序会根据客户端本地是否缓存了服务器的公钥而有所不同。如果客户端已经缓存了密钥，它会将被缓存密钥对应的算法提升到列表的靠前位置。中间人攻击者通过观察这个算法列表的顺序变化，就能够推断出客户端是否已经信任（即缓存了）目标服务器的密钥。

这个漏洞的严重等级为中等（CVSS 3.1 评分为 5.9）。它本身不能直接导致远程代码执行或权限提升，但它为中间人攻击者提供了非常关键的信息，使其能够发起更具针对性、更隐蔽的攻击。

------



### 漏洞举例说明



假设在一个公共 Wi-Fi 环境下，一名用户（受害者）想要通过 SSH 连接到公司的服务器（`company.com`）。此时，一名攻击者也在同一个网络中，并准备实施中间人攻击。

**攻击场景如下:**

1. **攻击者部署中间人环境**：攻击者使用 `ssh-mitm` 等工具，在网络中拦截受害者发往 `company.com` 的 SSH 连接请求。
2. **受害者发起 SSH 连接**：
   - **场景一：受害者首次连接服务器** 用户在终端输入 `ssh user@company.com`。由于是第一次连接，用户的电脑上没有 `company.com` 的主机密钥缓存。用户的 SSH 客户端会发送一个默认顺序的服务器主机密钥算法列表。
   - **场景二：受害者非首次连接服务器** 用户之前已经成功连接过 `company.com`，所以其 `~/.ssh/known_hosts` 文件中保存了 `company.com` 的公钥指纹。当用户再次输入 `ssh user@company.com` 时，其 SSH 客户端会将被缓存密钥（例如 `rsa-sha2-512`）对应的算法提升到支持列表的第一个位置。
3. **攻击者利用漏洞**： 中间人攻击工具（如 `ssh-mitm`）会捕获到客户端发来的算法协商包。
   - 通过分析算法列表，如果发现列表是默认顺序，攻击者就知道这是一个“新客户端”。对于新客户端，攻击者可以大胆地呈现一个伪造的服务器密钥，因为用户本来就会看到一个“首次连接，是否信任此主机？”的提示。很多用户会习惯性地输入 `yes`，从而落入中间人攻击的陷阱。攻击者可以窃取用户的密码、密钥，或者劫持整个 SSH 会话。
   - 如果发现算法列表的顺序被调整过，攻击者就知道了这是一个“老客户端”。对于老客户端，如果攻击者冒然提供一个伪造的密钥，客户端会立刻发出“**WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!**”的严重警告。这会立刻引起用户的警觉，导致攻击失败。因此，聪明的攻击者在探测到这是一个老客户端后，会选择放弃对该客户端的攻击，或者直接将流量透明地转发给真实的服务器，以避免暴露自己。

通过 CVE-2020-14145，攻击者可以有效地筛选出“容易上钩”的目标（首次连接的用户），从而大大提高中间人攻击的成功率和隐蔽性。

------



### 漏洞复现步骤



我们将使用 Docker 和 `ssh-mitm` 工具来复现这个漏洞。`ssh-mitm` 是一个强大的 SSH 中间人工具，它内置了对 CVE-2020-14145 的检测。

**实验环境:**

- **攻击机**: 任何安装了 Docker 的 Linux 主机。
- **受害机**: 一个包含旧版本 OpenSSH 客户端的 Docker 容器 (例如, Debian 10)。
- **目标服务器**: 一个标准的 SSH 服务器，这里我们可以用 Docker 快速启动一个。

------



#### **第一步：准备实验环境 (在攻击机上操作)**



1. **创建隔离的网络环境**

   为了让我们的容器能够相互通信，同时与主机隔离，我们创建一个 Docker 网络。

   Bash

   ```
   docker network create ssh-mitm-net
   ```

   - **解释**: 此命令创建了一个名为 `ssh-mitm-net` 的自定义桥接网络，后续的容器都将连接到这个网络中，方便它们通过容器名进行通信。

2. **启动目标 SSH 服务器**

   我们使用一个现成的 SSH 服务器镜像。

   Bash

   ```
   docker run -d --name ssh-server --network ssh-mitm-net -p 2222:22 -e "PASSWORD_ACCESS=true" -e "USER_NAME=testuser" -e "USER_PASSWORD=password" linuxserver/openssh-server
   ```

   - **解释**:
     - `-d`: 后台运行容器。
     - `--name ssh-server`: 将容器命名为 `ssh-server`。
     - `--network ssh-mitm-net`: 将容器连接到我们创建的网络。
     - `-p 2222:22`: 将主机的 2222 端口映射到容器的 22 端口。
     - `-e "..."`: 设置环境变量，这里我们允许密码登录，并创建了一个用户 `testuser`，密码为 `password`。

3. **启动受害机容器**

   我们使用一个 Debian 10 (Buster) 的镜像，该版本的 OpenSSH 客户端 (`OpenSSH_7.9p1`) 存在此漏洞。

   Bash

   ```
   docker run -it --name victim --network ssh-mitm-net debian:10
   ```

   - **解释**:
     - `-it`: 以交互模式启动并进入容器的 shell。
     - `--name victim`: 命名为 `victim`。
     - `debian:10`: 使用 Debian 10 镜像。

   进入容器后，安装 `openssh-client`。

   Bash

   ```
   # 在 victim 容器内执行
   apt-get update && apt-get install -y openssh-client
   ```

------



#### **第二步：启动中间人攻击**



1. **安装并运行 `ssh-mitm`**

   打开一个新的终端，在攻击机上使用 Docker 运行 `ssh-mitm`。

   Bash

   ```
   docker run -it --rm --name attacker --network ssh-mitm-net -p 10022:10022 sshmitm/ssh-mitm:latest server --remote-host ssh-server
   ```

   - **解释**:
     - `--rm`: 容器停止后自动删除。
     - `--name attacker`: 命名为 `attacker`。
     - `-p 10022:10022`: 将主机的 10022 端口映射到 `ssh-mitm` 服务的端口。
     - `sshmitm/ssh-mitm:latest`: 使用官方的 `ssh-mitm` Docker 镜像。
     - `server --remote-host ssh-server`: 这是 `ssh-mitm` 的启动命令，`server` 表示启动中间人服务器，`--remote-host ssh-server` 指定了真实的 SSH 服务器地址（在这里是我们的 `ssh-server` 容器名）。

   当 `ssh-mitm` 成功启动后，你会看到类似以下的日志信息，表示它正在监听 10022 端口。

   ```
   INFO     Starting SSH-MITM server on 0.0.0.0:10022
   ```

------



#### **第三步：演示漏洞**



现在，我们将从 `victim` 容器中发起 SSH 连接，并通过 `attacker` 的日志来观察漏洞的效果。

1. **首次连接 (模拟新用户)**

   回到 `victim` 容器的终端，执行以下命令，通过 `ssh-mitm` 代理连接到 `ssh-server`。

   Bash

   ```
   # 在 victim 容器内执行
   ssh -p 10022 testuser@attacker
   ```

   - **解释**: 我们连接的是 `attacker` 容器的 10022 端口，`ssh-mitm` 会将这个连接请求转发给 `ssh-server`。

   此时，你会看到首次连接的确认提示：

   ```
   The authenticity of host '[attacker]:10022 ([...])' can't be established.
   ECDSA key fingerprint is SHA256:....
   Are you sure you want to continue connecting (yes/no/[fingerprint])?
   ```

   同时，在 `attacker` 容器的日志中，你会看到关键信息：

   ```
   INFO     [CVE-2020-14145] Client connecting for the FIRST time!
   ```

   - **结果分析**: `ssh-mitm` 明确地告诉我们，这是一个首次连接的客户端。这是利用 CVE-2020-14145 漏洞得出的结论。

   在 `victim` 容器中输入 `yes` 并按回车，然后输入密码 `password` 即可登录。登录成功后，`victim` 容器的 `~/.ssh/known_hosts` 文件中就会保存 `attacker` 提供的主机密钥。

2. **再次连接 (模拟老用户)**

   在 `victim` 容器中，先 `exit` 退出 SSH 会话，然后再次执行相同的连接命令。

   Bash

   ```
   # 在 victim 容器内执行
   exit
   
   # 再次执行
   ssh -p 10022 testuser@attacker
   ```

   这次连接将直接提示输入密码，不会再有主机密钥确认的提示，因为密钥已经被信任并缓存了。

   现在，再次观察 `attacker` 容器的日志，你会看到不同的信息：

   ```
   INFO     [CVE-2020-14145] Client has a locally cached remote fingerprint!
   ```

   - **结果分析**: `ssh-mitm` 通过观察客户端发来的算法列表顺序的变化，成功地判断出这个客户端已经缓存了主机密钥。这证明了漏洞的存在和可利用性。攻击者可以根据这条信息来决定下一步的行动策略。

------



### 总结与缓解措施



CVE-2020-14145 是一个巧妙的漏洞，它揭示了 SSH 协议设计中一个细微但可被利用的缺陷。虽然它不能直接攻破系统，但却像一个“侦察兵”，为后续的中间人攻击提供了关键情报。

**缓解措施:**

1. **升级 OpenSSH 客户端**: 升级到 OpenSSH 8.5 或更高版本。虽然 OpenSSH 的开发者认为完全修复此问题可能会破坏协议兼容性，但在后续版本中已经加入了一些缓解措施。
2. **使用 SSH 证书**: 对于企业环境，强烈建议使用基于证书的认证方式。SSH 证书由一个可信的证书颁发机构（CA）签名，客户端只需要信任 CA 公钥，就可以验证所有由该 CA 签名的服务器证书，从而避免了“首次信任”的问题。
3. **预先配置主机密钥**: 在分发给用户的客户端中，可以预先将可信服务器的公钥添加到 `known_hosts` 文件中，避免用户进行手动确认。
4. **提高安全意识**: 对用户进行安全培训，告知他们不要在不安全的网络环境中轻易信任未知的 SSH 主机密钥，并对任何关于主机密钥变更的警告保持警惕。

<br> <hr> <br>



# CVE-2020-14145: Detailed Analysis, Example, and Reproduction



------



### Vulnerability Introduction



CVE-2020-14145 is an information disclosure vulnerability found in OpenSSH clients from version 5.7 to 8.4. The vulnerability stems from an "observable discrepancy" in the algorithm negotiation process between the client and the server. An attacker can leverage this discrepancy in a Man-in-the-Middle (MitM) scenario to determine whether the client is connecting to the server for the first time.

In simple terms, when an OpenSSH client connects to an SSH server for the first time, it does not know the server's public key fingerprint and will prompt the user for confirmation. If the client has connected to the server before, the server's public key information is cached in the local `known_hosts` file. On subsequent connections, the client uses this cached key information.

The core of CVE-2020-14145 is that when a client connects, it sends the server a list of supported host key algorithms. The order of this list differs depending on whether the client has the server's public key cached locally. If the key is cached, the client will promote the algorithm corresponding to the cached key to a higher position in the list. By observing this change in the algorithm list's order, a MitM attacker can infer whether the client already trusts (i.e., has cached) the target server's key.

The vulnerability has a medium severity rating (CVSS 3.1 score of 5.9). It does not directly lead to remote code execution or privilege escalation, but it provides critical information to a MitM attacker, enabling more targeted and stealthy attacks.

------



### Example of the Vulnerability



Imagine a user (the victim) trying to connect to their company's server (`company.com`) via SSH in a public Wi-Fi environment. An attacker is on the same network and is preparing a Man-in-the-Middle attack.

**Attack Scenario:**

1. **Attacker Sets Up MitM Environment**: The attacker uses tools like `ssh-mitm` to intercept the victim's SSH connection requests destined for `company.com`.
2. **Victim Initiates SSH Connection**:
   - **Scenario 1: Victim's First Connection** The user types `ssh user@company.com` in their terminal. Since it's the first connection, their computer has no cached host key for `company.com`. The user's SSH client sends a list of server host key algorithms in a default order.
   - **Scenario 2: Victim's Subsequent Connection** The user has previously connected to `company.com`, so their `~/.ssh/known_hosts` file contains its public key fingerprint. When the user enters `ssh user@company.com` again, their SSH client promotes the algorithm corresponding to the cached key (e.g., `rsa-sha2-512`) to the top of the supported list.
3. **Attacker Exploits the Vulnerability**: The MitM tool (like `ssh-mitm`) captures the algorithm negotiation packet sent by the client.
   - By analyzing the algorithm list, if the attacker sees the default order, they know this is a "new client." For a new client, the attacker can confidently present a fake server key because the user expects to see a "first connection, do you trust this host?" prompt. Many users will habitually type `yes` and fall into the MitM trap. The attacker can then steal the user's credentials or hijack the entire SSH session.
   - If the attacker sees that the algorithm list order has been altered, they know it's a "returning client." For a returning client, if the attacker presents a fake key, the client will immediately display a severe "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!" message. This will alert the user and cause the attack to fail. Therefore, a smart attacker, upon detecting a returning client, will choose to either abort the attack or transparently forward the traffic to the real server to avoid detection.

Through CVE-2020-14145, an attacker can effectively filter for "easy targets" (first-time connectors), significantly increasing the success rate and stealthiness of a MitM attack.

------



### Vulnerability Reproduction Steps



We will use Docker and the `ssh-mitm` tool to reproduce this vulnerability. `ssh-mitm` is a powerful SSH MitM tool with built-in detection for CVE-2020-14145.

**Lab Environment:**

- **Attacker Machine**: Any Linux host with Docker installed.
- **Victim Machine**: A Docker container with an old version of the OpenSSH client (e.g., Debian 10).
- **Target Server**: A standard SSH server, which we can quickly launch using Docker.

------



#### **Step 1: Prepare the Lab Environment (On the Attacker Machine)**



1. **Create an Isolated Network Environment**

   To allow our containers to communicate with each other while being isolated from the host, we create a Docker network.

   Bash

   ```
   docker network create ssh-mitm-net
   ```

   - **Explanation**: This command creates a custom bridge network named `ssh-mitm-net`. All subsequent containers will be connected to this network, allowing them to communicate using their container names.

2. **Start the Target SSH Server**

   We will use a ready-made SSH server image.

   Bash

   ```
   docker run -d --name ssh-server --network ssh-mitm-net -p 2222:22 -e "PASSWORD_ACCESS=true" -e "USER_NAME=testuser" -e "USER_PASSWORD=password" linuxserver/openssh-server
   ```

   - **Explanation**:
     - `-d`: Run the container in the background.
     - `--name ssh-server`: Name the container `ssh-server`.
     - `--network ssh-mitm-net`: Connect the container to our created network.
     - `-p 2222:22`: Map port 2222 on the host to port 22 in the container.
     - `-e "..."`: Set environment variables. Here we enable password authentication and create a user `testuser` with the password `password`.

3. **Start the Victim Container**

   We use a Debian 10 (Buster) image, as its OpenSSH client (`OpenSSH_7.9p1`) is vulnerable.

   Bash

   ```
   docker run -it --name victim --network ssh-mitm-net debian:10
   ```

   - **Explanation**:
     - `-it`: Start in interactive mode and attach a shell.
     - `--name victim`: Name the container `victim`.
     - `debian:10`: Use the Debian 10 image.

   Once inside the container, install the `openssh-client`.

   Bash

   ```
   # Execute inside the victim container
   apt-get update && apt-get install -y openssh-client
   ```

------



#### **Step 2: Launch the Man-in-the-Middle Attack**



1. **Install and Run `ssh-mitm`**

   Open a new terminal on the attacker machine and run `ssh-mitm` using Docker.

   Bash

   ```
   docker run -it --rm --name attacker --network ssh-mitm-net -p 10022:10022 sshmitm/ssh-mitm:latest server --remote-host ssh-server
   ```

   - **Explanation**:
     - `--rm`: Automatically remove the container when it exits.
     - `--name attacker`: Name the container `attacker`.
     - `-p 10022:10022`: Map port 10022 on the host to the `ssh-mitm` service port.
     - `sshmitm/ssh-mitm:latest`: Use the official `ssh-mitm` Docker image.
     - `server --remote-host ssh-server`: This is the `ssh-mitm` command. `server` starts the MitM server, and `--remote-host ssh-server` specifies the address of the real SSH server (in our case, the `ssh-server` container).

   When `ssh-mitm` starts successfully, you will see log messages similar to the following, indicating it is listening on port 10022.

   ```
   INFO     Starting SSH-MITM server on 0.0.0.0:10022
   ```

------



#### **Step 3: Demonstrate the Vulnerability**



Now, we will initiate SSH connections from the `victim` container and observe the vulnerability's effect through the `attacker`'s logs.

1. **First Connection - Simulating a New User**

   Go back to the `victim` container's terminal and execute the following command to connect to `ssh-server` through the `ssh-mitm` proxy.

   Bash

   ```
   # Execute inside the victim container
   ssh -p 10022 testuser@attacker
   ```

   - **Explanation**: We are connecting to port 10022 of the `attacker` container. `ssh-mitm` will forward this connection request to `ssh-server`.

   At this point, you will see the first-time connection prompt:

   ```
   The authenticity of host '[attacker]:10022 ([...])' can't be established.
   ECDSA key fingerprint is SHA256:....
   Are you sure you want to continue connecting (yes/no/[fingerprint])?
   ```

   Meanwhile, in the `attacker` container's logs, you will see the key information:

   ```
   INFO     [CVE-2020-14145] Client connecting for the FIRST time!
   ```

   - **Result Analysis**: `ssh-mitm` explicitly tells us that this is a client connecting for the first time. This conclusion is drawn by exploiting the CVE-2020-14145 vulnerability.

   In the `victim` container, type `yes` and press Enter, then enter the password `password` to log in. Upon successful login, the `victim` container's `~/.ssh/known_hosts` file will save the host key provided by the `attacker`.

2. **Second Connection - Simulating a Returning User**

   In the `victim` container, first `exit` the SSH session, then execute the same connection command again.

   Bash

   ```
   # Execute inside the victim container
   exit
   
   # Execute again
   ssh -p 10022 testuser@attacker
   ```

   This time, the connection will directly prompt for a password without the host key confirmation prompt, as the key is now trusted and cached.

   Now, observe the `attacker` container's logs again, and you will see a different message:

   ```
   INFO     [CVE-2020-14145] Client has a locally cached remote fingerprint!
   ```

   - **Result Analysis**: By observing the change in the order of the algorithm list sent by the client, `ssh-mitm` successfully determined that this client already has the host key cached. This proves the existence and exploitability of the vulnerability. The attacker can use this information to decide on their next course of action.

------



### Summary and Mitigation



CVE-2020-14145 is a subtle vulnerability that exposes a minor but exploitable flaw in the SSH protocol design. While it cannot directly compromise a system, it acts like a "scout," providing critical intelligence for subsequent Man-in-the-Middle attacks.

**Mitigation Measures:**

1. **Upgrade OpenSSH Client**: Upgrade to OpenSSH version 8.5 or newer. Although OpenSSH developers believe a complete fix might break protocol compatibility, some mitigations have been added in later versions.
2. **Use SSH Certificates**: For enterprise environments, using certificate-based authentication is highly recommended. SSH certificates are signed by a trusted Certificate Authority (CA). The client only needs to trust the CA's public key to verify all server certificates signed by that CA, thus avoiding the "trust on first use" problem.
3. **Pre-configure Host Keys**: In client deployments, you can pre-populate the `known_hosts` file with the public keys of trusted servers to prevent users from needing to manually confirm them.
4. **Increase Security Awareness**: Train users not to blindly trust unknown SSH host keys in insecure network environments and to be vigilant about any warnings regarding changed remote host keys.