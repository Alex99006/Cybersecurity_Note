# AX2004M漏洞复现

## 一、固件的提取和启动

~~~apl
binwalk -Me ax2004m_ml_14_190.bin  #  固件提取
sudo ./run.sh -d AX2004M ./firmwares/../../../gujian/IPTIME_AX2004/ax2004m_ml_14_190.bin  #  使用 firmAE 启动程序 并访问成功
#  启动程序后先链接 shell 并使用 ps 查看所启动的服务为 httpd 服务
~~~

![](/Image/IPTIME_AX2004M/ipt-1.png)

## 二、分析研判

~~~apl
#  访问成功后可以可以看到登录界面
#  登录界面是用户名是写死的 admin 并在密码栏也发现passwd is admin
#  尝试使用admin admin登录
#  这时我们提前开启 burp 抓包并使用 admin admin 登录
#  登录进入后我们可以看到 版本号和设置功能
#  点击设置功能进入 这时我们观察到了在进入设置功能后我们的 URL 发生了变化
#  这时我们去观察一下 burp 的情况会发现有大量的请求是在 timepro.cgi 走的
#  由此我们可以大概推断出这个 timepro.cgi 可能是一个敏感文件
~~~

![](/Image/IPTIME_AX2004M/ipt-3.png)

![](/Image/IPTIME_AX2004M/ipt-4.png)

## 三、定位敏感文件并分析

~~~apl
find ./ -name timepro 2>/dev/null  #  定位文件位置得到回显为./cgibin/timepro.cgi和./home/httpd/cgi/timpor.cgi
cd home/httpd/cgi  #  进入后
ls -la  #  查看到如下图（后面会用到）
#  找到这个文件丢入 IDA 进行分析
~~~

![](/Image/IPTIME_AX2004M/ipt-10.png)

~~~apl
#  进入 IDA 后显示是 start 函数
#  我们可以看到 跳转了 sub_40A7E4
#  跟进 sub_40A7E4 发现了 _libc_start_main
#  而 _libc_start_main 中的参数有 ftext
#  ftext 是一个典型的 CGI/HTTP 请求处理入口函数（渲染 web UI、响应 POST/GET 表单、处理配置提交、页面路由等）。它把大量 UI 逻辑、POST 处理、页面选择和输出都放在一个函数里。
#  所以我们需要进入ftext函数看看
#  它先初始化日志，再对“会话相关 URL”执行认证检查（httpcon_check_session_url() + httpcon_auth()），认证通过后初始化 UI（install_ui(&ui)）
~~~

![](/Image/IPTIME_AX2004M/ipt-6.png)

~~~apl
#  发现是外部调用函数，所以我们还是需要先去找到这个check 在哪
grep -ir httpcon_check_session_url  #  检索相关文件 得到回显lib/libsession.so
#  把 lib/libsession.so 丢入IDA 分析 check 函数在做什么 但是通过命名我们可以大概猜测应该是在做一个 url 的检查
#  通过具体分析发现果然是
#   httpcon_auth(1, 1)有以下判断

#  从命名看，它负责认证或权限校验。
#  参数 (1, 1) 很可能代表：
	#  	auth_type = 1（例如用户登录验证）
	#  	auth_level = 1（例如普通用户权限）

#  返回值：
	#  	true (非零)：认证通过；
	#  	false (0)：认证失败。

~~~

![](/Image/IPTIME_AX2004M/ipt-7.png)

~~~apl
( httpcon_check_session_url() && !httpcon_auth(1, 1) )
#  通过上述分析可以得知 只要这两个条件都成立，就会进入执行install_ui(&ui)
#  分析反推 得到 2 个结论
#  	1、如果认证函数逻辑存在缺陷（例如 httpcon_auth() 被绕过），
#      就能在未认证的情况下继续执行 install_ui(&ui)；
#	  2、如果 install_ui() 内部涉及命令执行、注册回调或文件修改，
#      那就可能导致认证绕过 + RCE（远程代码执行）。
#  所以我们开始进入验证猜想环节
~~~

~~~apl
          +-------------------------+
          | check_session_url()     |
          +-----------+-------------+
                      |
              Yes      |       No
               |       |       
       +-------v-------+     
       | httpcon_auth(1,1) |
       +---+---------------+
           | Yes   |  No
           |       | 
        +--v--+   +--v--+
        |install_ui| return 0
        +------+   +------+
~~~



## 四、漏洞验证

~~~apl
#  我们先看一下正常的带 cookie 的
~~~

![](/Image/IPTIME_AX2004M/ipt-8.png)

~~~apl
#  在看一下绕过的结果
#  这里说明一下为什么是使用 /cgi/
#  最开始我们研判思路为：修改/sess-bin/为任意路径的时候就可以绕过，等我们输入随意的路径的实际，发现并不能请求成功。这时候就怀疑可能还是做了一个校验，既然是做了校验的话，推测大概率是会在/sess-bin/的附近做的校验。带着这个想法。我们回到 IDA 搜索 sess-bin 看看能找到什么。结果找到了如下图.
#  由于我们看到了在未启动的时候 timepro.cgi指向为黑洞，启动后会指向/cgibin/通过下图伪C 的研判 所以我们直接尝试使用非/sess-bin/和/cgibin/但是还有关联的/cgi/进行绕过。发送请求后得到了 200 ok。 所以我们的验证成功了。说明存在未授权漏洞
~~~

![](/Image/IPTIME_AX2004M/ipt-12.png)

![](/Image/IPTIME_AX2004M//ipt-13.png)

![](/Image/IPTIME_AX2004M/ipt-10.png)

![](/Image/IPTIME_AX2004M/ipt-11.png)

![](/Image/IPTIME_AX2004M/ipt-9.png)

## 五、通过未授权修改账号密码

~~~apl
#  先正常去修改一下我们的账号密码 并使用 burp 抓包来查看我们的请求值
#  captcha_file captcha_code new_passwd  new_login
#  这个需要注意 captcha_file = MpSmayQ2g6VC1hbkw0hY6U1j27jCzQ9M captcha_code = uayaf
-------------------------
#  现在我们开始构造未授权登录的请求
~~~



![](/Image/IPTIME_AX2004M/ipt-15.png)

![](/Image/IPTIME_AX2004M/ipt-14.png)

![](/Image/IPTIME_AX2004M/ipt-16.png)

## 六、通过远程调节进行命令执行

~~~apl
#  根据漏洞信息披露，该路由器的远程调试功能能够被利用进行命令执行
#  首先我们要实现这个，我们需要先去开启路由器中的远程调试功能
#  开始远程调试路径：Adva..setup-->system-->micssetup-->remote..-->start
#  开启的时候还是需要开启 burp 去抓包查看请求信息
#  去 IDA 中搜索相关字节并定位相关函数
#  调用get_remote_support 函数把远程的状态存入到remote_support中 因为只用先开启页面后才可以进行远程调试状态的设置，所以开启页面也会调用到这个函数，接下来在 IDA 中进行交叉引用找到了 show_debug函数，并分析
#  带有remotesupport字节的 html 代码的意思是生成一个单选按钮（Radio Button）及其关联标签，其中 %s 占位符分别用于动态插入该按钮的选中状态（如 "checked"）和用户可见的文本标签。
#  分析 show_dbug 函数可以得知：当在满足若干条件（远端支持、非默认口令、并通过一个隐蔽的参数校验或特权标识）时，它能够显示指定文件内容并且可执行任意 shell 命令（通过 popen），并把输出返回到 HTTP 响应中。函数包含一段隐蔽的字节序列校验（类似魔术字符串/密钥）以及对 fdump / fname / cmd 等 GET 参数的处理。
#  把函数中校验的值全部转为 ACSII 码得到 正确密钥 !@dnjsrurelqjrm*&
~~~

~~~apl
#  程序逻辑流程图
start
  └─> if (!get_remote_support()) return result
       └─> if ( check_default_pass() ) return result      // 拒绝默认口令场景
           └─> 初始化 dest=""
           └─> read hidden flag: get_value(a1, unk_490204, v22, 32)
               └─> if v22 != "1" goto LABEL_51 (常规 UI)
               └─> read aaksjdkfj into dest via get_value(a1, "aaksjdkfj", dest, 256)
                    └─> if provided -> 对 dest 以及后续栈字节做**逐字节魔术串**校验
                         └─> 如果魔术串校验通过 -> (privileged path?) 跳过部分检查，继续 LABEL_51 后的执行
LABEL_51:
    if hidden flag == "1" && fdump == "on" && fname provided:
       fopen(fname) -> print file contents -> return
    else:
       render HTML form (fname/cmd/aaksjdkfj)
       if form submitted && hidden flag == "1":
           if fname provided -> fopen(fname) -> print in <font>
           build command: "2>&1 " + cmd + " 2>&1"
           popen(command, "r") -> read stdout/stderr -> print in <pre>
return

~~~

~~~apl
#  总结分析
#  任意命令执行（RCE）：popen + 未过滤的 cmd 参数 
#  任意文件读取：fopen + fname(filename,"r")  （任意文件读取）。
#  潜在缓冲区溢出 / 栈破坏：get_value(..., dest, 256) vs dest[6]；command 追加越界 —— 高危，可导致崩溃或利用。
#  后门/隐藏秘钥：隐蔽参数与硬编码字节判断 —— （后门）。
#  认证/开关依赖脆弱：功能依赖 get_remote_support() 与 check_default_pass()；配置不当或被误改，会导致后门开启。
~~~



![](/Image/IPTIME_AX2004M/ipt-17.png)

![](/Image/IPTIME_AX2004M/ipt-18.png)

![](/Image/IPTIME_AX2004M/ipt-19.png)

![](/Image/IPTIME_AX2004M/ipt-20.png)

![](/Image/IPTIME_AX2004M/ipt-21.png)

![](/Image/IPTIME_AX2004M/ipt-22.png)

## 七、漏洞复现

~~~apl
#  使用 burp 抓包，随意找一个请求
#  构造请求头地址 ⚠️：cookie 的 session_id是有时效性的(也就是说是需要使用最新的)
#  为什么要去构造地址为/sess-bin/d.cgi  如果请求的 URI (*a2) 等于 "/cgibin/d.cgi"，则调用 show_debug_screen(a2)
#  构造完成后，发送到浏览器中执行命令  成功回显
~~~

![](/Image/IPTIME_AX2004M/ipt-23.png)

![](/Image/IPTIME_AX2004M/ipt-24.png)

![](/Image/IPTIME_AX2004M/ipt-25.png)

![](/Image/IPTIME_AX2004M/ipt-26.png)

------

# **AX2004M Vulnerability Reproduction**

## **1. Firmware Extraction and Booting**

```apl
binwalk -Me ax2004m_ml_14_190.bin  # Extract firmware
sudo ./run.sh -d AX2004M ./firmwares/../../../gujian/IPTIME_AX2004/ax2004m_ml_14_190.bin  # Start firmware using firmAE and access successfully
# After startup, connect to the shell and use ps to view the running service. It is httpd.
```



![](/Image/IPTIME_AX2004M/ipt-1.png)



## **2. Analysis and Assessment**

```apl
# After accessing successfully, the login page is displayed.
# The username is hardcoded as admin, and the password field also shows "passwd is admin".
# Try to log in using admin / admin.
# Enable Burp Suite in advance and capture the login request.
# After logging in, we see the version number and the Settings feature.
# Clicking Settings changes the URL path.
# Observing Burp Suite traffic, we see that many requests are made to timepro.cgi.
# This suggests timepro.cgi may be a sensitive file.
```



![](/Image/IPTIME_AX2004M/ipt-3.png)



![](/Image/IPTIME_AX2004M/ipt-4.png)



## **3. Locating and Analyzing the Sensitive File**

```apl
find ./ -name timepro 2>/dev/null  # Locate the file; result: ./cgibin/timepro.cgi and ./home/httpd/cgi/timepro.cgi
cd home/httpd/cgi
ls -la  # As shown in the image (used later)
# Open the timepro.cgi file in IDA Pro for analysis.
```



![](/Image/IPTIME_AX2004M/ipt-10.png)

```apl
# In IDA, the first function is start().
# It jumps to sub_40A7E4.
# Entering sub_40A7E4, we see a call to _libc_start_main.
# One of the parameters for _libc_start_main is ftext.
# ftext is a typical CGI/HTTP request handler (web UI rendering, POST/GET processing, routing, etc).
# So we need to examine the ftext function.
# It initializes logs, then performs session-related URL authentication
# (httpcon_check_session_url() + httpcon_auth()).
# If authentication succeeds, install_ui(&ui) is executed.
```



![](/Image/IPTIME_AX2004M/ipt-6.png)

```apl
# httpcon_check_session_url is an external function,
# so we search for it in the firmware.
grep -ir httpcon_check_session_url
# Found in: lib/libsession.so
# Load libsession.so into IDA and analyze the check() function.
# As expected, it performs URL validation.

# httpcon_auth(1, 1):
#   auth_type = 1    (login authentication)
#   auth_level = 1   (normal user)
# Return value:
#   non-zero: authenticated
#   zero: authentication failed
```



![](/Image/IPTIME_AX2004M/ipt-7.png)

```apl
( httpcon_check_session_url() && !httpcon_auth(1, 1) )
# From the analysis, we can conclude:
# 1. If httpcon_auth() can be bypassed due to flawed logic,
#    install_ui(&ui) can be executed without authentication.
# 2. If install_ui() includes command execution or file modification,
#    this may lead to authentication bypass + RCE.

# Begin hypothesis testing.
          +-------------------------+
          | check_session_url()     |
          +-----------+-------------+
                      |
              Yes      |       No
               |       |       
       +-------v-------+     
       | httpcon_auth(1,1) |
       +---+---------------+
           | Yes   |  No
           |       | 
        +--v--+   +--v--+
        |install_ui| return 0
        +------+   +------+
```



## **4. Vulnerability Validation**

```apl
# First, observe a normal authenticated request with a valid cookie:
```



![](/Image/IPTIME_AX2004M/ipt-8.png)

```apl
# Now observe the bypass result.
# Why use /cgi/?
# Initially we assumed that modifying '/sess-bin/' to any arbitrary path could bypass authentication.
# But this failed.
# We suspected additional path validation existed near ‘/sess-bin/’.

# Searching for 'sess-bin' in IDA revealed relevant logic (image below).

# We saw that before startup, timepro.cgi points to a blackhole,
# and after startup it points to /cgibin/.

# Therefore, we tried using the related but different directory '/cgi/'.
# The response returned HTTP 200 OK → authentication bypass confirmed.
```



![](/Image/IPTIME_AX2004M/ipt-12.png)

![](/Image/IPTIME_AX2004M/ipt-13.png)

![](/Image/IPTIME_AX2004M/ipt-10.png)

![](/Image/IPTIME_AX2004M/ipt-11.png)

![](/Image/IPTIME_AX2004M/ipt-9.png)



## **5. Unauthorized Modification of Account Password**

```apl
# First, normally attempt to modify the router admin credentials while capturing the request with Burp.
# Parameters captured:
#   captcha_file = MpSmayQ2g6VC1hbkw0hY6U1j27jCzQ9M
#   captcha_code = uayaf
#   new_passwd
#   new_login

# Now construct the same request but WITHOUT authentication (no cookie).
```

![](/Image/IPTIME_AX2004M/ipt-15.png)

![](/Image/IPTIME_AX2004M/ipt-14.png)
 ![](/Image/IPTIME_AX2004M/ipt-16.png)



## **6. Achieving RCE via Remote Debugging**

```apl
# According to the vulnerability disclosure, the router’s remote debugging feature can be abused to execute commands.

# To enable remote debugging:
# Advanced setup → system → miscsetup → remote → start
# Capture the request via Burp Suite.

# Search for the related bytes in IDA and locate the responsible function.
# get_remote_support reads remote debugging status.
# show_debug handles the debug screen logic.
# The HTML code contains remotesupport variables used to render radio buttons.

# Detailed analysis shows:
# If several conditions are met (remote enabled, non-default password,
# and a hidden parameter with a magic-key validation),
# then the function allows:
#     - Displaying arbitrary files (fopen)
#     - Executing arbitrary commands (popen)

# The hidden magic string is:
#     !@dnjsrurelqjrm*&
Program Logic Overview:

start
 └─> if (!get_remote_support()) return
      └─> if (check_default_pass()) return
           └─> init dest = ""
           └─> read hidden flag (unknown param)
               └─> if flag != "1" → UI only
               └─> else read param "aaksjdkfj" into dest
                    └─> magic string validation
                         └─> if passed → privileged mode
LABEL_51:
  if hidden flag == "1" & fdump == "on" & fname provided:
       fopen(fname) → print file → return
  else:
       render debug HTML
       if submitted & flag == "1":
           if fname → fopen → print
           build command: "2>&1 " + cmd + " 2>&1"
           popen(command) → print output
# Summary:
#  - Arbitrary Command Execution (popen)
#  - Arbitrary File Read (fopen)
#  - Hidden Backdoor Key (!@dnjsrurelqjrm*&)
#  - Weak authentication and hidden parameters
```

![](/Image/IPTIME_AX2004M/ipt-17.png)
![](/Image/IPTIME_AX2004M/ipt-18.png)

![](/Image/IPTIME_AX2004M/ipt-19.png)

![](/Image/IPTIME_AX2004M/ipt-20.png)

![](/Image/IPTIME_AX2004M/ipt-21.png)

![](/Image/IPTIME_AX2004M/ipt-22.png)

------

## **7. Full Exploit Reproduction**

```apl
# Use Burp Suite to capture a request.
# Construct a malicious request to /sess-bin/d.cgi

# Why /sess-bin/d.cgi?
# Because if the requested URI equals "/cgibin/d.cgi",
# the program directly calls show_debug_screen(a2),
# giving access to the RCE backdoor.

# After constructing the request, forward it to the browser.
# Command execution succeeds (RCE).
```

![](/Image/IPTIME_AX2004M/ipt-23.png)

![](/Image/IPTIME_AX2004M/ipt-24.png)

![](/Image/IPTIME_AX2004M/ipt-25.png)

![](/Image/IPTIME_AX2004M/ipt-26.png)
